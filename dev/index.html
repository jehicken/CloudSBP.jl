<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CloudSBP.jl</title><meta name="title" content="Home · CloudSBP.jl"/><meta property="og:title" content="Home · CloudSBP.jl"/><meta property="twitter:title" content="Home · CloudSBP.jl"/><meta name="description" content="Documentation for CloudSBP.jl."/><meta property="og:description" content="Documentation for CloudSBP.jl."/><meta property="twitter:description" content="Documentation for CloudSBP.jl."/><meta property="og:url" content="https://jehicken.github.io/CloudSBP.jl/"/><meta property="twitter:url" content="https://jehicken.github.io/CloudSBP.jl/"/><link rel="canonical" href="https://jehicken.github.io/CloudSBP.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CloudSBP.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jehicken/CloudSBP.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CloudSBP"><a class="docs-heading-anchor" href="#CloudSBP">CloudSBP</a><a id="CloudSBP-1"></a><a class="docs-heading-anchor-permalink" href="#CloudSBP" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/jehicken/CloudSBP.jl">CloudSBP</a>.</p><ul><li><a href="#CloudSBP.BoundaryOperator-Tuple{Type}"><code>CloudSBP.BoundaryOperator</code></a></li><li><a href="#CloudSBP.BoundaryOperator"><code>CloudSBP.BoundaryOperator</code></a></li><li><a href="#CloudSBP.CellData"><code>CloudSBP.CellData</code></a></li><li><a href="#CloudSBP.Dissipation"><code>CloudSBP.Dissipation</code></a></li><li><a href="#CloudSBP.Face-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Int64, StaticArraysCore.SVector{Dim, T}, StaticArraysCore.SVector{Dim, T}}, Tuple{Int64, StaticArraysCore.SVector{Dim, T}, StaticArraysCore.SVector{Dim, T}, Union{Nothing, Cell}}, Tuple{Int64, StaticArraysCore.SVector{Dim, T}, StaticArraysCore.SVector{Dim, T}, Union{Nothing, Cell}, Union{Nothing, Cell}}} where {Dim, T, Cell}"><code>CloudSBP.Face</code></a></li><li><a href="#CloudSBP.Face"><code>CloudSBP.Face</code></a></li><li><a href="#CloudSBP.LevelSetRefinery"><code>CloudSBP.LevelSetRefinery</code></a></li><li><a href="#CloudSBP.Mesh"><code>CloudSBP.Mesh</code></a></li><li><a href="#CloudSBP.PointRefinery"><code>CloudSBP.PointRefinery</code></a></li><li><a href="#CloudSBP.SBP"><code>CloudSBP.SBP</code></a></li><li><a href="#CloudSBP.add_face_to_boundary!-Union{Tuple{T}, Tuple{CloudSBP.BoundaryOperator{T}, Any, Any, Any}} where T"><code>CloudSBP.add_face_to_boundary!</code></a></li><li><a href="#CloudSBP.add_face_to_boundary!-Union{Tuple{T}, Tuple{CloudSBP.BoundaryOperator{T}, Vararg{Any, 4}}} where T"><code>CloudSBP.add_face_to_boundary!</code></a></li><li><a href="#CloudSBP.add_face_to_boundary!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{CloudSBP.BoundaryOperator{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 4}}} where {Data, Dim, T, L}"><code>CloudSBP.add_face_to_boundary!</code></a></li><li><a href="#CloudSBP.apply_approx_inverse!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.apply_approx_inverse!</code></a></li><li><a href="#CloudSBP.boundary_operators-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.boundary_operators</code></a></li><li><a href="#CloudSBP.boundary_sym_part-NTuple{4, Any}"><code>CloudSBP.boundary_sym_part</code></a></li><li><a href="#CloudSBP.boundary_sym_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.boundary_sym_part</code></a></li><li><a href="#CloudSBP.boundary_sym_part-Tuple{Any, Any, Any}"><code>CloudSBP.boundary_sym_part</code></a></li><li><a href="#CloudSBP.build_boundary_face-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Int64, RegionTrees.Cell{Data, Dim, T, L}}} where {Data, Dim, T, L}"><code>CloudSBP.build_boundary_face</code></a></li><li><a href="#CloudSBP.build_boundary_faces-Union{Tuple{RegionTrees.Cell{Data, Dim, T, L}}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}} where {Data, Dim, T, L}"><code>CloudSBP.build_boundary_faces</code></a></li><li><a href="#CloudSBP.build_cell_stencils!-Tuple{Any, Any, Any}"><code>CloudSBP.build_cell_stencils!</code></a></li><li><a href="#CloudSBP.build_face-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Int64, RegionTrees.Cell{Data, Dim, T, L}, RegionTrees.Cell{Data, Dim, T, L}}} where {Data, Dim, T, L}"><code>CloudSBP.build_face</code></a></li><li><a href="#CloudSBP.build_face_dissipation-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Array{Face{Dim, T, Cell}, 1}, Any, Any, Any}} where {Dim, T, Cell}"><code>CloudSBP.build_face_dissipation</code></a></li><li><a href="#CloudSBP.build_first_derivative-NTuple{6, Any}"><code>CloudSBP.build_first_derivative</code></a></li><li><a href="#CloudSBP.build_interfaces-Union{Tuple{RegionTrees.Cell{Data, Dim, T, L}}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}} where {Data, Dim, T, L}"><code>CloudSBP.build_interfaces</code></a></li><li><a href="#CloudSBP.build_interpolation!-NTuple{6, Any}"><code>CloudSBP.build_interpolation!</code></a></li><li><a href="#CloudSBP.build_mesh-Union{Tuple{T}, Tuple{Dim}, Tuple{Any, StaticArraysCore.SVector{Dim, T}, Any, Any}} where {Dim, T}"><code>CloudSBP.build_mesh</code></a></li><li><a href="#CloudSBP.build_nn_stencils!-Tuple{Any, Any, Any}"><code>CloudSBP.build_nn_stencils!</code></a></li><li><a href="#CloudSBP.calc_error-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Function, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 4}}} where {Data, Dim, T, L}"><code>CloudSBP.calc_error</code></a></li><li><a href="#CloudSBP.calc_moments!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.calc_moments!</code></a></li><li><a href="#CloudSBP.calc_moments!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any}} where {Data, Dim, T, L}"><code>CloudSBP.calc_moments!</code></a></li><li><a href="#CloudSBP.cell_null_and_part-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_null_and_part</code></a></li><li><a href="#CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, AbstractMatrix{ComplexF64}, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_quadrature</code></a></li><li><a href="#CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, AbstractMatrix{ComplexF64}, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_quadrature</code></a></li><li><a href="#CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_quadrature</code></a></li><li><a href="#CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_quadrature</code></a></li><li><a href="#CloudSBP.cell_quadrature_rev!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_quadrature_rev!</code></a></li><li><a href="#CloudSBP.cell_quadrature_rev!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_quadrature_rev!</code></a></li><li><a href="#CloudSBP.cell_side_rect-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, RegionTrees.Cell{Data, Dim, T, L}}} where {Data, Dim, T, L}"><code>CloudSBP.cell_side_rect</code></a></li><li><a href="#CloudSBP.cell_skew_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.cell_skew_part</code></a></li><li><a href="#CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.cell_symmetric_part</code></a></li><li><a href="#CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Array{Face{Dim, T, RegionTrees.Cell{Data, Dim, T, L}}, 1}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.cell_symmetric_part</code></a></li><li><a href="#CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.cell_symmetric_part</code></a></li><li><a href="#CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Array{Face{Dim, T, RegionTrees.Cell{Data, Dim, T, L}}, 1}, Any, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.cell_symmetric_part</code></a></li><li><a href="#CloudSBP.compute_sparse_constraint-NTuple{4, Any}"><code>CloudSBP.compute_sparse_constraint</code></a></li><li><a href="#CloudSBP.dgd_basis!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.dgd_basis!</code></a></li><li><a href="#CloudSBP.dgd_basis_rev!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.dgd_basis_rev!</code></a></li><li><a href="#CloudSBP.diagonal_norm!-Tuple{Any, Any}"><code>CloudSBP.diagonal_norm!</code></a></li><li><a href="#CloudSBP.diagonal_norm!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.diagonal_norm!</code></a></li><li><a href="#CloudSBP.diagonal_norm_rev!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.diagonal_norm_rev!</code></a></li><li><a href="#CloudSBP.diff_jacobi_poly-Union{Tuple{T}, Tuple{AbstractVector{T}, Any, Any, Int64}} where T"><code>CloudSBP.diff_jacobi_poly</code></a></li><li><a href="#CloudSBP.diff_proriol_poly!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64, Int64}} where T"><code>CloudSBP.diff_proriol_poly!</code></a></li><li><a href="#CloudSBP.diff_proriol_poly!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64}} where T"><code>CloudSBP.diff_proriol_poly!</code></a></li><li><a href="#CloudSBP.face_quadrature!-Union{Tuple{T}, Tuple{Dim}, Tuple{Any, Any, RegionTrees.HyperRectangle{Dim, T}, Any, Any, Int64}} where {Dim, T}"><code>CloudSBP.face_quadrature!</code></a></li><li><a href="#CloudSBP.get_bounding_box-Tuple{Any, Any}"><code>CloudSBP.get_bounding_box</code></a></li><li><a href="#CloudSBP.get_complex_step-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Float32"><code>CloudSBP.get_complex_step</code></a></li><li><a href="#CloudSBP.get_data-Tuple{Any, Any}"><code>CloudSBP.get_data</code></a></li><li><a href="#CloudSBP.get_neighbors-Tuple{RegionTrees.Cell, Any}"><code>CloudSBP.get_neighbors</code></a></li><li><a href="#CloudSBP.get_null_and_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.get_null_and_part</code></a></li><li><a href="#CloudSBP.get_points_inside"><code>CloudSBP.get_points_inside</code></a></li><li><a href="#CloudSBP.indices_within_parent-Tuple{Any}"><code>CloudSBP.indices_within_parent</code></a></li><li><a href="#CloudSBP.interface_interp-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Vararg{Any, 4}}} where {Dim, T, Cell}"><code>CloudSBP.interface_interp</code></a></li><li><a href="#CloudSBP.interface_interp-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Any, Any, Any}} where {Dim, T, Cell}"><code>CloudSBP.interface_interp</code></a></li><li><a href="#CloudSBP.interface_skew_part-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Any, Any, Any}} where {Dim, T, Cell}"><code>CloudSBP.interface_skew_part</code></a></li><li><a href="#CloudSBP.interface_skew_part-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Vararg{Any, 4}}} where {Dim, T, Cell}"><code>CloudSBP.interface_skew_part</code></a></li><li><a href="#CloudSBP.is_center_immersed-Union{Tuple{T}, Tuple{Dim}, Tuple{RegionTrees.HyperRectangle{Dim, T}, Function}} where {Dim, T}"><code>CloudSBP.is_center_immersed</code></a></li><li><a href="#CloudSBP.is_cut-Tuple{Any}"><code>CloudSBP.is_cut</code></a></li><li><a href="#CloudSBP.is_cut-Union{Tuple{T}, Tuple{Dim}, Tuple{RegionTrees.HyperRectangle{Dim, T}, Function}} where {Dim, T}"><code>CloudSBP.is_cut</code></a></li><li><a href="#CloudSBP.is_cut-Union{Tuple{Face{Dim, T, Cell}}, Tuple{Cell}, Tuple{T}, Tuple{Dim}} where {Dim, T, Cell}"><code>CloudSBP.is_cut</code></a></li><li><a href="#CloudSBP.is_immersed-Tuple{Any}"><code>CloudSBP.is_immersed</code></a></li><li><a href="#CloudSBP.is_immersed-Union{Tuple{Face{Dim, T, Cell}}, Tuple{Cell}, Tuple{T}, Tuple{Dim}} where {Dim, T, Cell}"><code>CloudSBP.is_immersed</code></a></li><li><a href="#CloudSBP.jacobi_poly!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Any, Any, Int64, AbstractVector{T}}} where T"><code>CloudSBP.jacobi_poly!</code></a></li><li><a href="#CloudSBP.leaves_on_side-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Int64}} where {Data, Dim, T, L}"><code>CloudSBP.leaves_on_side</code></a></li><li><a href="#CloudSBP.lg_nodes"><code>CloudSBP.lg_nodes</code></a></li><li><a href="#CloudSBP.lgl_nodes"><code>CloudSBP.lgl_nodes</code></a></li><li><a href="#CloudSBP.make_compatible!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.make_compatible!</code></a></li><li><a href="#CloudSBP.mark_cut_cells!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Function}} where {Data, Dim, T, L}"><code>CloudSBP.mark_cut_cells!</code></a></li><li><a href="#CloudSBP.mark_cut_faces!-Tuple{Any, Any}"><code>CloudSBP.mark_cut_faces!</code></a></li><li><a href="#CloudSBP.mass_matrix-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.mass_matrix</code></a></li><li><a href="#CloudSBP.mass_obj-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.mass_obj</code></a></li><li><a href="#CloudSBP.mass_obj_grad!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.mass_obj_grad!</code></a></li><li><a href="#CloudSBP.mass_row_sums!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.mass_row_sums!</code></a></li><li><a href="#CloudSBP.mass_row_sums_rev!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.mass_row_sums_rev!</code></a></li><li><a href="#CloudSBP.max_leaf_stencil-Tuple{Any}"><code>CloudSBP.max_leaf_stencil</code></a></li><li><a href="#CloudSBP.monomial_basis!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, Val{1}}} where T"><code>CloudSBP.monomial_basis!</code></a></li><li><a href="#CloudSBP.monomial_basis_derivatives!-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, AbstractMatrix{T}, Val{1}}} where T"><code>CloudSBP.monomial_basis_derivatives!</code></a></li><li><a href="#CloudSBP.neighbor_of_greater_or_equal_size-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Int64}} where {Data, Dim, T, L}"><code>CloudSBP.neighbor_of_greater_or_equal_size</code></a></li><li><a href="#CloudSBP.num_leaves-Tuple{Any}"><code>CloudSBP.num_leaves</code></a></li><li><a href="#CloudSBP.number_immersed-Tuple{Any}"><code>CloudSBP.number_immersed</code></a></li><li><a href="#CloudSBP.obj_norm-Union{Tuple{T2}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, AbstractArray{Vector{T2}, 1}, AbstractArray{Matrix{T2}, 1}, AbstractVector{T2}, T2, Int64}} where {Data, Dim, T, L, T2}"><code>CloudSBP.obj_norm</code></a></li><li><a href="#CloudSBP.obj_norm_grad!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, AbstractArray{Vector{T}, 1}, AbstractArray{Matrix{T}, 1}, AbstractVector{T}, T, Int64}} where {Data, Dim, T, L}"><code>CloudSBP.obj_norm_grad!</code></a></li><li><a href="#CloudSBP.obj_slice-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 7}}} where {Data, Dim, T, L}"><code>CloudSBP.obj_slice</code></a></li><li><a href="#CloudSBP.opt_norm!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.opt_norm!</code></a></li><li><a href="#CloudSBP.output_pyplot-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.output_pyplot</code></a></li><li><a href="#CloudSBP.output_vtk-Union{Tuple{L}, Tuple{T}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, 2, T, L}, Any, Any, Any}} where {Data, T, L}"><code>CloudSBP.output_vtk</code></a></li><li><a href="#CloudSBP.penalty-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.penalty</code></a></li><li><a href="#CloudSBP.penalty_grad!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.penalty_grad!</code></a></li><li><a href="#CloudSBP.point_data_vtk-Tuple{Any, Any, Any}"><code>CloudSBP.point_data_vtk</code></a></li><li><a href="#CloudSBP.points_vtk-Tuple{Any}"><code>CloudSBP.points_vtk</code></a></li><li><a href="#CloudSBP.poly_basis!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, AbstractVector{T}, Val{1}}} where T"><code>CloudSBP.poly_basis!</code></a></li><li><a href="#CloudSBP.poly_basis_derivatives!-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, AbstractMatrix{T}, Val{1}}} where T"><code>CloudSBP.poly_basis_derivatives!</code></a></li><li><a href="#CloudSBP.proriol_poly!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64, Int64, AbstractVector{T}}} where T"><code>CloudSBP.proriol_poly!</code></a></li><li><a href="#CloudSBP.proriol_poly!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64, AbstractVector{T}}} where T"><code>CloudSBP.proriol_poly!</code></a></li><li><a href="#CloudSBP.push_new_face!-Union{Tuple{T}, Tuple{CloudSBP.BoundaryOperator{T}, Any, Any, Any}} where T"><code>CloudSBP.push_new_face!</code></a></li><li><a href="#CloudSBP.quadrature!-Union{Tuple{T}, Tuple{Dim}, Tuple{Any, Any, RegionTrees.HyperRectangle{Dim, T}, Any, Any}} where {Dim, T}"><code>CloudSBP.quadrature!</code></a></li><li><a href="#CloudSBP.refine_on_levelset!-NTuple{4, Any}"><code>CloudSBP.refine_on_levelset!</code></a></li><li><a href="#CloudSBP.refine_on_points!-Tuple{Any, Any}"><code>CloudSBP.refine_on_points!</code></a></li><li><a href="#CloudSBP.set_xref_and_dx!-Tuple{Any, Any}"><code>CloudSBP.set_xref_and_dx!</code></a></li><li><a href="#CloudSBP.skew_operator-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 5}}} where {Data, Dim, T, L}"><code>CloudSBP.skew_operator</code></a></li><li><a href="#CloudSBP.solve_min_norm!-Tuple{Any, Any, Any}"><code>CloudSBP.solve_min_norm!</code></a></li><li><a href="#CloudSBP.solve_min_norm_diff!-NTuple{5, Any}"><code>CloudSBP.solve_min_norm_diff!</code></a></li><li><a href="#CloudSBP.solve_min_norm_rev!-NTuple{4, Any}"><code>CloudSBP.solve_min_norm_rev!</code></a></li><li><a href="#CloudSBP.solve_norm!-NTuple{4, Any}"><code>CloudSBP.solve_norm!</code></a></li><li><a href="#CloudSBP.stencil_stats-Tuple{CloudSBP.Mesh}"><code>CloudSBP.stencil_stats</code></a></li><li><a href="#CloudSBP.symmetric_operator-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 5}}} where {Data, Dim, T, L}"><code>CloudSBP.symmetric_operator</code></a></li><li><a href="#CloudSBP.tensor_basis!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, AbstractVector{T}, Val{1}}} where T"><code>CloudSBP.tensor_basis!</code></a></li><li><a href="#CloudSBP.unsteady_vtk-Union{Tuple{L}, Tuple{T}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, 2, T, L}, Vararg{Any, 4}}} where {Data, T, L}"><code>CloudSBP.unsteady_vtk</code></a></li><li><a href="#RegionTrees.needs_refinement-Tuple{CloudSBP.PointRefinery, Any}"><code>RegionTrees.needs_refinement</code></a></li><li><a href="#RegionTrees.needs_refinement-Tuple{CloudSBP.LevelSetRefinery, Any}"><code>RegionTrees.needs_refinement</code></a></li><li><a href="#RegionTrees.refine_data-Tuple{CloudSBP.LevelSetRefinery, RegionTrees.Cell, Any}"><code>RegionTrees.refine_data</code></a></li><li><a href="#RegionTrees.refine_data-Tuple{CloudSBP.PointRefinery, RegionTrees.Cell, Any}"><code>RegionTrees.refine_data</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.BoundaryOperator" href="#CloudSBP.BoundaryOperator"><code>CloudSBP.BoundaryOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Data for integrals on boundaries</p><p>Each boundary condition can be associated with a <code>BoundaryOperator</code>, which  holds data needed to compute integrals over the relevant subset of the  boundary.  This data is grouped by faces, since each face may require a  different number of quadrature points or have a different sized stencil.  If  <code>f</code> denotes the index of some face, then <code>xq_face[f][:,q]</code> is the <code>q</code>th  quadrature point on face; <code>nrm_face[f][:,q]</code> is the quadrature-weighted outward  facing normal at <code>xq_face[f][:,q]</code>; <code>dof_face[f][i]</code> is global DOF index  associated with the local interpolation index <code>i</code>, and; <code>prj_face[f][q,:]</code> is  the interpolation operator from the local degrees of freedom to quadrature node  <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/first_derivative.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.BoundaryOperator-Tuple{Type}" href="#CloudSBP.BoundaryOperator-Tuple{Type}"><code>CloudSBP.BoundaryOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">E = BoundaryOperator(T)</code></pre><p>Returns a <code>BoundaryOperator</code> with empty arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/first_derivative.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.CellData" href="#CloudSBP.CellData"><code>CloudSBP.CellData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Data associated with a RegionTree <code>Cell</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.Dissipation" href="#CloudSBP.Dissipation"><code>CloudSBP.Dissipation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Face-based dissipation operator</p><p><code>w_face</code> are the interface areas, <code>x_face</code> are the face centers, <code>R_left</code> and  <code>R_right</code> are interpolation operators to the faces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/dissipation.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.Face" href="#CloudSBP.Face"><code>CloudSBP.Face</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Struct for interfaces and boundary faces of cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/face.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.Face-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Int64, StaticArraysCore.SVector{Dim, T}, StaticArraysCore.SVector{Dim, T}}, Tuple{Int64, StaticArraysCore.SVector{Dim, T}, StaticArraysCore.SVector{Dim, T}, Union{Nothing, Cell}}, Tuple{Int64, StaticArraysCore.SVector{Dim, T}, StaticArraysCore.SVector{Dim, T}, Union{Nothing, Cell}, Union{Nothing, Cell}}} where {Dim, T, Cell}" href="#CloudSBP.Face-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Int64, StaticArraysCore.SVector{Dim, T}, StaticArraysCore.SVector{Dim, T}}, Tuple{Int64, StaticArraysCore.SVector{Dim, T}, StaticArraysCore.SVector{Dim, T}, Union{Nothing, Cell}}, Tuple{Int64, StaticArraysCore.SVector{Dim, T}, StaticArraysCore.SVector{Dim, T}, Union{Nothing, Cell}, Union{Nothing, Cell}}} where {Dim, T, Cell}"><code>CloudSBP.Face</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">f = Face(dir, origin, widths [, data=nothing])</code></pre><p>Construct a face with normal direction index <code>dir</code>, with corner at <code>origin</code>,  and having <code>widths</code> dimensions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/face.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.LevelSetRefinery" href="#CloudSBP.LevelSetRefinery"><code>CloudSBP.LevelSetRefinery</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">r = LevelSetRefinery(point_subset)</code></pre><p>Used during to refine the mesh around a given level-set.  Refines until the cut  cells are less than <code>r.min_widths</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L133-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.Mesh" href="#CloudSBP.Mesh"><code>CloudSBP.Mesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Mesh data structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mesh.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.PointRefinery" href="#CloudSBP.PointRefinery"><code>CloudSBP.PointRefinery</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">r = PointRefinery(point_subset)</code></pre><p>Used during mesh refinement with respect to a given point cloud; see RegionTree  documentation for addition information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.SBP" href="#CloudSBP.SBP"><code>CloudSBP.SBP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Summation-by-parts first derivative operator</p><p><code>S[d]</code> holds the skew-symmetric part for direction <code>d</code> and <code>E[:]</code> holds <code>BoundaryOperator</code>s that define the symmetric part.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/first_derivative.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.add_face_to_boundary!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{CloudSBP.BoundaryOperator{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 4}}} where {Data, Dim, T, L}" href="#CloudSBP.add_face_to_boundary!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{CloudSBP.BoundaryOperator{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 4}}} where {Data, Dim, T, L}"><code>CloudSBP.add_face_to_boundary!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_face_to_boundary!(bndry, cell, xc, degree, levset, levset_grad!
                      [, fit_degree=degree])</code></pre><p>This version of the method is for faces that are the intersection between the level-set <code>levset(x)=0</code> and the cell <code>cell</code>.  In addition to the level-set, this function needs a function that can compute the gradient of the level-set, <code>levset_grad!(g, x)</code> which returns the gradient at <code>x</code> in the array <code>g</code>.  As usual, <code>fit_degree</code> indicates the degree of the Bernstein polynomials used to  approximate the level-set within the Algoim library.</p><p><strong>NOTE</strong>: we use <code>2*degree+1</code> nodes in each direction for the surface quadrature, since it must integrate the normal in addition to the flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/first_derivative.jl#L117-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.add_face_to_boundary!-Union{Tuple{T}, Tuple{CloudSBP.BoundaryOperator{T}, Any, Any, Any}} where T" href="#CloudSBP.add_face_to_boundary!-Union{Tuple{T}, Tuple{CloudSBP.BoundaryOperator{T}, Any, Any, Any}} where T"><code>CloudSBP.add_face_to_boundary!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_face_to_boundary!(bndry, face, xc, degree)</code></pre><p>Computes the quadrature points, normal vector, degrees of freedom, and  interpolation operator for the face <code>face</code> and adds this data to the given  <code>BoundaryOperator</code>, <code>bndry</code>.  <code>xc</code> are the locations of the nodes in the  stencil of <code>face</code>, and <code>degree</code> determines the order of accuracy of the  quadrature (<code>2*degree+1</code>) and the interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/first_derivative.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.add_face_to_boundary!-Union{Tuple{T}, Tuple{CloudSBP.BoundaryOperator{T}, Vararg{Any, 4}}} where T" href="#CloudSBP.add_face_to_boundary!-Union{Tuple{T}, Tuple{CloudSBP.BoundaryOperator{T}, Vararg{Any, 4}}} where T"><code>CloudSBP.add_face_to_boundary!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_face_to_boundary!(bndry, face, xc, degree, levset [, fit_degree=degree])</code></pre><p>This version of the method is for planar boundary faces that are cut by the level-set geometry defined by the function <code>levset</code>.  The optional kwarg  <code>fit_degree</code> indicates the degree of the Bernstein polynomials used to  approximate the level-set within the Algoim library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/first_derivative.jl#L89-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.apply_approx_inverse!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}" href="#CloudSBP.apply_approx_inverse!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.apply_approx_inverse!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_approx_inverse!(p, g, root, xc, dist_ref, H_tol, mu, degree, max_rank)</code></pre><p>Finds a low-rank approximation to the inverse Hessian of the objective <code>penalty</code>, and applies this to <code>-g</code> to get a search direction <code>p</code>.  The background mesh is <code>root</code>, <code>xc</code> are the nodes/points, <code>dist_ref</code> is an array of reference distances for each node, <code>mu</code> is the regularization parameter, <code>degree</code> is the target degree.  The rank of the approximation is controlled by  <code>max_rank</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/node_opt.jl#L452-L461">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.boundary_operators-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}" href="#CloudSBP.boundary_operators-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.boundary_operators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">E = boundary_operators(root, bc_map, bfaces, xc, levset, levset_grad!, 
                       degree [, fit_degree=degree])</code></pre><p>Generates a set of <code>BoundaryOperator</code>s for each of the <code>2*Dim</code> planar boundary as well as the immersed surface within the domain of the root cell <code>root</code>. <code>bc_map</code> is a Dictionary that maps boundaries to boundary conditions; the key used for a planar boundaries is its side index:</p><ul><li>1 – EAST (root.boundary.origin[1])</li><li>2 – WEST (root.boundary.origin[1] + root.boundary.width[1])</li><li>3 – SOUTH (root.boundary.origin[2])</li><li>4 – NORTH (root.boundary.origin[2] + root.boundary.width[2])</li><li>5 – BOTTOM (root.boundary.origin[3])</li><li>6 – TOP (root.boundary.origin[3] + root.boundary.width[3])</li></ul><p>The key for the immersed surface is the string &quot;ib&quot;.  All the planar boundary faces are stored in <code>bfaces</code>.  The DOF coordinates are given by <code>xc</code>. The immersed surface is defined by <code>levset(x) = 0</code>, and the gradient of this level set is <code>g</code> after calling <code>levset_grad!(g,x)</code>.  The formal polynomial accuracy of the boundary operator is <code>degree</code>, while <code>fit_degree</code> gives the degree of the Bernstein polynomial used by Algoim to fit <code>levset</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/first_derivative.jl#L163-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.boundary_sym_part-NTuple{4, Any}" href="#CloudSBP.boundary_sym_part-NTuple{4, Any}"><code>CloudSBP.boundary_sym_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">E = boundary_sym_part(face, xc, degree, levset [, fit_degree=degree])</code></pre><p>This version of the method is for planar boundary faces that are cut by the level-set geometry defined by the function <code>levset</code>.  The optional kwarg  <code>fit_degree</code> indicates the degree of the Bernstein polynomials used to  approximate the level-set within the Algoim library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/symmetric_part.jl#L362-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.boundary_sym_part-Tuple{Any, Any, Any}" href="#CloudSBP.boundary_sym_part-Tuple{Any, Any, Any}"><code>CloudSBP.boundary_sym_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">E = boundary_sym_part(face, xc, degree)</code></pre><p>Returns the symmetric boundary form </p><p><span>$\int_{\text{face}} V_i V_j n_{	ext{dir}} d\Gamma$</span></p><p>where the integral is over the face <code>face</code> with unit normal in the coordinate direction <code>face.dir</code>.  The functions <span>$V_i$</span> and <span>$V_j$</span> can be regarded as degree <code>degree</code> basis functions at the nodes <code>i</code> and <code>j</code> within the stencil of the cell whose stencil&#39;s coordinates are <code>xc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/symmetric_part.jl#L326-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.boundary_sym_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.boundary_sym_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.boundary_sym_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">E = boundary_sym_part!(cell, xc, degree, levset [, fit_degree=degree])</code></pre><p>This version of the method is for faces that are the intersection between the level-set <code>levset(x)=0</code> and the cell <code>cell</code>.  As usual, <code>fit_degree</code> indicates the degree of the Bernstein polynomials used to approximate the level-set within the Algoim library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/symmetric_part.jl#L391-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.build_boundary_face-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Int64, RegionTrees.Cell{Data, Dim, T, L}}} where {Data, Dim, T, L}" href="#CloudSBP.build_boundary_face-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Int64, RegionTrees.Cell{Data, Dim, T, L}}} where {Data, Dim, T, L}"><code>CloudSBP.build_boundary_face</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">f = build_boundary_face(dir, cell)</code></pre><p>Construct a boundary face with normal direction index <code>dir</code> having adjacent  element <code>cell</code>.  With this constructor, <code>dir</code> can be negative.  For example,  <code>dir=1</code> is an East face, while <code>dir=-1</code> is a West face.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/face.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.build_boundary_faces-Union{Tuple{RegionTrees.Cell{Data, Dim, T, L}}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}} where {Data, Dim, T, L}" href="#CloudSBP.build_boundary_faces-Union{Tuple{RegionTrees.Cell{Data, Dim, T, L}}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}} where {Data, Dim, T, L}"><code>CloudSBP.build_boundary_faces</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">faces = build_boundary_faces(root)</code></pre><p>Creates an array of boundary faces of the tree <code>root</code>.  Boundary faces are  faces of the leaves of <code>root</code> that touch the the East, West, North, ...etc  sides of <code>root</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mesh.jl#L150-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.build_cell_stencils!-Tuple{Any, Any, Any}" href="#CloudSBP.build_cell_stencils!-Tuple{Any, Any, Any}"><code>CloudSBP.build_cell_stencils!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_cell_stencils!(mesh, points, degree [, tol=5*10^degree, 
                     max_iter=2*degree+1])</code></pre><p>This method loops over the cells in <code>mesh</code> and constructs the stencil for  each.  The stencil is based on the nodes <code>points</code> and the polynomial <code>degree</code>.   The function also determines the cell reference dimensions for affine scaling  of the Vandermonde matrix.  See <code>build_nn_stencils!</code> for an explanation of  <code>tol</code> and <code>max_iter</code>.</p><p><strong>NOTE</strong>: If you want a degree <code>p</code> SBP operator, set <code>degree=2*p-1</code> so that the  stencil is sufficiently large for the diagonal mass matrix.</p><p><strong>TODO</strong>: At present this is just a front-end for <code>build_nn_stencils!</code>.  In the future we may want an input that allows for different stencil constructions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mesh.jl#L249-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.build_face-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Int64, RegionTrees.Cell{Data, Dim, T, L}, RegionTrees.Cell{Data, Dim, T, L}}} where {Data, Dim, T, L}" href="#CloudSBP.build_face-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Int64, RegionTrees.Cell{Data, Dim, T, L}, RegionTrees.Cell{Data, Dim, T, L}}} where {Data, Dim, T, L}"><code>CloudSBP.build_face</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">f = build_face(dir, left, right)</code></pre><p>Construct a face with normal direction index <code>dir</code> having adjacent cells  <code>left</code> and <code>right</code>.  With this constructor, <code>dir</code> is always positive, and  points from <code>left</code> to <code>right</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/face.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.build_face_dissipation-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Array{Face{Dim, T, Cell}, 1}, Any, Any, Any}} where {Dim, T, Cell}" href="#CloudSBP.build_face_dissipation-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Array{Face{Dim, T, Cell}, 1}, Any, Any, Any}} where {Dim, T, Cell}"><code>CloudSBP.build_face_dissipation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">face_diss = build_face_dissipation(ifaces, xc, degree, levset,
                                   [, fit_degree=degree])</code></pre><p>Returns a <code>Dissipation</code> type that can be used for artificial dissipation over a  point cloud.  <code>iface</code> is a list of interfaces, and <code>xc[:,i]</code> are the  coordinates of the ith point in the cloud.  <code>degree</code> is the polynomial degree  for which the interpolations to the faces is exact.  <code>levset</code> defines a  level-set geometry, and the optional kwarg <code>fit_degree</code> indicates the degree of  the Bernstein polynomials used to approximate the level-set within the Algoim  library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/dissipation.jl#L77-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.build_first_derivative-NTuple{6, Any}" href="#CloudSBP.build_first_derivative-NTuple{6, Any}"><code>CloudSBP.build_first_derivative</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sbp = build_first_derivative(mesh, bc_map, xc, levset, levset_grad!, degree
                             [, fit_degree=degree])</code></pre><p>Constructs first-derivative SBP operators of degree <code>degree</code> based on the  background <code>mesh</code>, nodes <code>xc</code>, level-set <code>levset</code> (and its gradient,  <code>levset_grad!</code>).  <code>fit_degree</code> sets the polynomial degree used by Algoim to  approximate the level set.  <code>bc_map</code> determines the type of each boundary.</p><p><strong>PRE</strong>: The cell norms must be stored in the cell data.wts[:] attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/first_derivative.jl#L223-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.build_interfaces-Union{Tuple{RegionTrees.Cell{Data, Dim, T, L}}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}} where {Data, Dim, T, L}" href="#CloudSBP.build_interfaces-Union{Tuple{RegionTrees.Cell{Data, Dim, T, L}}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}} where {Data, Dim, T, L}"><code>CloudSBP.build_interfaces</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">faces = build_interfaces(root)</code></pre><p>Creates an array of faces between adjacent leaves (i.e. cells) of the tree  <code>root</code>.  This array does not include boundary faces that have only one adjacent  cell; see <code>build_boundary_faces</code> for such a list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mesh.jl#L124-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.build_interpolation!-NTuple{6, Any}" href="#CloudSBP.build_interpolation!-NTuple{6, Any}"><code>CloudSBP.build_interpolation!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_interpolation!(interp, degree, x, x_interp, xref, dx)</code></pre><p>Creates the matrix <code>interp</code> that performs interpolation from nodes <code>x</code> to points <code>x_interp</code>, which is <code>degree</code> total polynomial degree exact.  The  arrays <code>xref</code> and <code>dx</code> are used to shift and scale the coordinates to  improve the conditioning of the Vandermonde matrix.</p><p><strong>Note:</strong> This routine assumes that <code>x</code> is unisolvent.  Also, the matrix  <code>interp</code> is the minmum-norm solution when there are more nodes in <code>x</code> than  total <code>degree</code> basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/utils.jl#L68-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.build_mesh-Union{Tuple{T}, Tuple{Dim}, Tuple{Any, StaticArraysCore.SVector{Dim, T}, Any, Any}} where {Dim, T}" href="#CloudSBP.build_mesh-Union{Tuple{T}, Tuple{Dim}, Tuple{Any, StaticArraysCore.SVector{Dim, T}, Any, Any}} where {Dim, T}"><code>CloudSBP.build_mesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mesh = build_mesh(points, widths, levset, min_width 
                  [, origin=SVector(ntuple(i -&gt; 0.0, Dim))])</code></pre><p>Builds the background Cartesian mesh.  The root cell has its origin at <code>origin</code>  and has <code>widths</code> lengths.  The level-set <code>levset</code> defines any immersed boundary  based on where <code>levset(x) = 0</code>; the domain is the intersection of the root  cell&#39;s domain and where <code>levset(x) &gt;= 0</code>.  The mesh is refined based on the  given points <code>points</code> and it is refined at the zero level-set until the cut  cell have dimensions of <code>min_width</code> or smaller.</p><p><strong>NOTE</strong>: If you want a degree <code>p</code> SBP operator, set <code>degree=2*p-1</code> so that the  stencil is sufficiently large for the diagonal mass matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mesh.jl#L213-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.build_nn_stencils!-Tuple{Any, Any, Any}" href="#CloudSBP.build_nn_stencils!-Tuple{Any, Any, Any}"><code>CloudSBP.build_nn_stencils!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_nn_stencils!(root, points, degree [, tol=5*10^degree, 
                   max_iter=2*degree+1])</code></pre><p>The stencil for each leaf in the tree <code>root</code> is determined and the indices of  the stencil are stored in the leaves.  The stencil is determined using <code>k</code>  neareast neighbors, where <code>k</code> is the number of points needed for a  well-conditioned Vandermonde matrix of total degree <code>degree</code>.  The tolerance  <code>tol</code> is used to determine what is considered well-conditioned.  A maximum of  <code>max_iter</code> iterations are used to find a suitable stencil; after the maximum  iterations are exceeded, the method accepts the stencil as is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mesh.jl#L15-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.calc_error-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Function, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 4}}} where {Data, Dim, T, L}" href="#CloudSBP.calc_error-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Function, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 4}}} where {Data, Dim, T, L}"><code>CloudSBP.calc_error</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">L2_error, max_error = calc_error(exact, root, xc, degree, u, levset [, 
                                 quad_degree=2*degree, fit_degree=degree])</code></pre><p>Returns the L2 and max error of a given solution <code>u</code>.  The exact solution is  provided by the function <code>exact</code>.  The background mesh is <code>root</code> and the nodes  are <code>xc</code>.  <code>degree</code> is the degree of the solution, while <code>quad_degree</code> and  <code>fit_degree</code> are the quadrature and level-set <code>levset</code> fitting degrees,  respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/output.jl#L163-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.calc_moments!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.calc_moments!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.calc_moments!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">m = calc_moments!(root, levset, degree, fit_degree)</code></pre><p>Returns the first total <code>degree</code> integral moments for all cells in the tree defined by <code>root</code>.  The tree must have been preprocessed to identify poentially cut and immersed cells using the <code>levset</code> level-set function.  In addition, the  <code>cell.data.xref</code> and <code>cell.data.dx</code> fields must contain the reference origin for each cell.</p><p>WARNING: The signature of the function <code>levset</code> must of the form levset(Vector{Float64})::Float64, because this assumption is used when it is wrapped using <code>csafe_function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/norm.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.calc_moments!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any}} where {Data, Dim, T, L}" href="#CloudSBP.calc_moments!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any}} where {Data, Dim, T, L}"><code>CloudSBP.calc_moments!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">m = calc_moments!(root, degree)</code></pre><p>This variant is useful when you want moments for all cells in the tree <code>root</code>,  i.e. no level-set function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/norm.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_null_and_part-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Val{Dim}}} where Dim" href="#CloudSBP.cell_null_and_part-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_null_and_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">w = cell_null_and_part(degree, xc, moments, xref, dx, Val(Dim))</code></pre><p>Given a set of total <code>degree</code> polynomial <code>moments</code>, computes a quadrature that is exact for those moments based on the nodes <code>xc</code> as well as the null space of the quadrature conditions  The arrays <code>xref</code> and <code>dx</code> are used to shift and scale, respectively, the nodes in <code>xc</code> to improve conditioning of the Vandermonde matrix.  The same scaling and shifts must have been applied when computing the integral <code>moments</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/norm.jl#L214-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, AbstractMatrix{ComplexF64}, Any, Any, Any, Val{Dim}}} where Dim" href="#CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, AbstractMatrix{ComplexF64}, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_quadrature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">w = cell_quadrature(degree, xc, moments, xref, dx, Val(Dim))</code></pre><p>Partially complexified version of <code>cell_quadrature</code>; partially, because  <code>solve_min_norm!</code> does not work with complex variables, so that function is  differentiated explicitly here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/node_opt.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, AbstractMatrix{ComplexF64}, Any, Any, Val{Dim}}} where Dim" href="#CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, AbstractMatrix{ComplexF64}, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_quadrature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">w = cell_quadrature(degree, xc, xq, wq, Val(Dim))</code></pre><p>Complexified version of <code>cell_quadrature</code> for testing derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/node_opt.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Val{Dim}}} where Dim" href="#CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_quadrature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">w = cell_quadrature(degree, xc, moments, xref, dx, Val(Dim))</code></pre><p>Given a set of total <code>degree</code> polynomial <code>moments</code>, computes a quadrature that is exact for those moments based on the nodes <code>xc</code>.  The arrays <code>xref</code> and <code>dx</code> are used to shift and scale, respectively, the nodes in <code>xc</code> to improve  conditioning of the Vandermonde matrix.  The same scaling and shifts must have been applied when computing the integral <code>moments</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/norm.jl#L129-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Val{Dim}}} where Dim" href="#CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_quadrature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">w = cell_quadrature(degree, xc, xq, wq, Val(Dim))</code></pre><p>Given a quadrature rule <code>(xq,wq)</code> that is exact for polynomials of <code>degree</code>  degree, computes a new quadrature for the same domain based on the nodes <code>xc</code>.  This version computes the moments from scratch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/norm.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_quadrature_rev!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim" href="#CloudSBP.cell_quadrature_rev!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_quadrature_rev!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cell_quadrature_rev!(xc_bar, degree, xc, moments, xref, dx, w_bar, Val(Dim))</code></pre><p>Reverse mode differentiated of the moment-based variant of <code>cell_quadrature</code>. Returns the derivatives of <code>dot(w, w_bar)</code> with respect to <code>xc</code> in the array <code>xc_bar</code>.  All other inputs are the same as the moment-based variant of <code>cell_quadrature</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/node_opt.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_quadrature_rev!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim" href="#CloudSBP.cell_quadrature_rev!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.cell_quadrature_rev!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cell_quadrature_rev!(xc_bar, degree, xc, xq, wq, w_bar, Val(Dim))</code></pre><p>Reverse mode differentiated <code>cell_quadrature</code>.  Returns the derivatives of  <code>dot(w, w_bar)</code> with respect to <code>xc</code> in the array <code>xc_bar</code>.  All other inputs are the same as <code>cell_quadrature</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/node_opt.jl#L119-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_side_rect-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, RegionTrees.Cell{Data, Dim, T, L}}} where {Data, Dim, T, L}" href="#CloudSBP.cell_side_rect-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, RegionTrees.Cell{Data, Dim, T, L}}} where {Data, Dim, T, L}"><code>CloudSBP.cell_side_rect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rect = build_cell_face(dir, cell)</code></pre><p>Construct a <code>HyperRectangle</code> for given cell on side <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/symmetric_part.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_skew_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.cell_skew_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.cell_skew_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">S = cell_skew_part(E, H, cell, xc, degree)</code></pre><p>Returns the skew-symmetric parts of SBP diagonal-norm operators for the element <code>cell</code> based on the nodes <code>xc</code>.  The operator is exact for polynomials of total  degree <code>degree</code>.  The diagonal norm for the cell is provided in the array <code>H</code>,  which must be exact for degree <code>2*degree - 1</code> polynomials over <code>xc</code>.  Finally, the symmetric part of the SBP operators must be provided in <code>E</code>.  Note that <code>E</code> and the returned <code>S</code> are three dimensional arrays, with <code>E[:,:,d]</code> and <code>S[:,:,d]</code> holding the operators for the direction <code>d</code>.</p><p><strong>NOTE</strong>: E and H must be compatible, in the sense of SBP operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/skew_part.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.cell_symmetric_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">E = cell_symmetric_part(cell, xc, degree, levset [,fit_degree=degree])</code></pre><p>Returns the symmetric part of the first-derivative SBP operator for the  <em>possibly</em> cut cell <code>cell</code>.  The point cloud associated with <code>cell</code> is <code>xc</code>,  and the boundary operator uses <code>2*degree</code> exact quadrature.  The <code>fit_degree</code> input indicates the degree of the Bernstein polynomial used by Algoim to approximate the level set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/symmetric_part.jl#L59-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.cell_symmetric_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">E = cell_symmetric_part(cell, xc, degree)</code></pre><p>Returns the symmetric part of the first-derivative SBP operator for the uncut  cell <code>cell</code>.  The point cloud associated with <code>cell</code> is <code>xc</code>, and the boundary  operator is <code>2*degree</code> exact for boundary integrals.</p><p><strong>Note</strong>: This version recomputes the 1D quadrature rule each time, and involves several allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/symmetric_part.jl#L22-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Array{Face{Dim, T, RegionTrees.Cell{Data, Dim, T, L}}, 1}, Any, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Array{Face{Dim, T, RegionTrees.Cell{Data, Dim, T, L}}, 1}, Any, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.cell_symmetric_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">E = cell_symmetric_part(cell, faces, xc, degree, levset [,fit_degree=degree])</code></pre><p>Returns the symmetric part of the first-derivative SBP operator for the  <em>possibly</em> cut cell <code>cell</code>.  The point cloud associated with <code>cell</code> is <code>xc</code>,  and the boundary operator uses <code>2*degree</code> exact quadrature.  The <code>fit_degree</code> input indicates the degree of the Bernstein polynomial used by Algoim to approximate the level set.  This variant loops over the <code>faces</code> of the cell, which is not necessary for uncut cells but it is necessary for cut cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/symmetric_part.jl#L173-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Array{Face{Dim, T, RegionTrees.Cell{Data, Dim, T, L}}, 1}, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Array{Face{Dim, T, RegionTrees.Cell{Data, Dim, T, L}}, 1}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.cell_symmetric_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">E = cell_symmetric_part(cell, faces, xc, degree)</code></pre><p>Returns the symmetric part of the first-derivative SBP operator for the uncut  cell <code>cell</code>.  The point cloud associated with <code>cell</code> is <code>xc</code>, and the boundary  operator is <code>2*degree</code> exact for boundary integrals.  This variant loops over the <code>faces</code> of the cell, which is not necessary for uncut cells but it is necessary for cut cells.</p><p><strong>Note</strong>: This version recomputes the 1D quadrature rule each time, and involves several allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/symmetric_part.jl#L127-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.compute_sparse_constraint-NTuple{4, Any}" href="#CloudSBP.compute_sparse_constraint-NTuple{4, Any}"><code>CloudSBP.compute_sparse_constraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">A, b = compute_sparse_constraint(root, wp, Z, H_tol)</code></pre><p>Returns the sparse matrix <code>A</code> and vector <code>b</code> that make up the linear inequality  for the diagonal mass matrix.  <code>root</code> is used to loop over the cells and  assemble the null-space matrices stored in <code>Z</code> and the minimum-norm quadrature  stored in <code>wp</code>.  <code>H_tol</code> is an array of tolerances for the diagonal entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/norm.jl#L280-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.dgd_basis!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim" href="#CloudSBP.dgd_basis!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.dgd_basis!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dgd_basis!(phi, degree, xc, xq, work, Val(Dim))</code></pre><p>Evaluates the DGD basis functions <code>phi</code> at the points <code>xq</code>.  The basis functions are of total degree <code>degree</code>, and they are defined by the centers  <code>xc</code>.  The array <code>work</code> is used for temporary storage, and the value type <code>Dim</code>  is used to dispatch on the relevant dimension.</p><p>If <code>ndims(phi) &gt; 2</code>, it is assumed that both the basis functions (stored in phi [:,:,q]) and their derivatives (stored in phi[:,:,2:Dim+1]) are to be  computed.  Otherwise, the basis functions are computed and returned in the 2d  array <code>phi[:,:]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/dgd_basis.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.dgd_basis_rev!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim" href="#CloudSBP.dgd_basis_rev!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim"><code>CloudSBP.dgd_basis_rev!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dgd_basis_rev!(xc_bar, phi_bar, degree, xc, xq, xref, dx, Val(Dim))</code></pre><p>Reverse mode algorithmic differentiation of <code>dgd_basis!</code>.  The output <code>xc_bar</code>  is the derivative of the output (defined implicitly by the input <code>phi_bar</code>) as  a function of the coordinates in <code>xc</code>.  As in <code>dgd_basis!</code>, the basis functions  are of total degree <code>degree</code>, evaluated at points <code>xq</code>, and they are defined by  the centers <code>xc</code>.  The value type <code>Dim</code> is used to dispatch on the relevant  dimension.</p><p><em>Note</em>: Only differentiates the version of <code>dgd_basis!</code> that returns the basis functions, not their derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/dgd_basis.jl#L108-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.diagonal_norm!-Tuple{Any, Any}" href="#CloudSBP.diagonal_norm!-Tuple{Any, Any}"><code>CloudSBP.diagonal_norm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diagonal_norm!(H, root)</code></pre><p>Assembles the diagonal norm <code>H</code> using the particular cell-based norm stored in  the cells&#39; <code>data.wts</code> field.  <code>root</code> stores the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/norm.jl#L194-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.diagonal_norm!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.diagonal_norm!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.diagonal_norm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diagonal_norm!(H, root, points, degree)</code></pre><p>Constructs a diagonal norm (i.e. quadrature) for the nodes <code>points</code> and using the background mesh defined by <code>root</code>.</p><p><strong>PRE</strong>: The cells in <code>root</code> must have their <code>data.moments</code>, <code>data.xref</code>, and <code>data.dx</code> fields set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/norm.jl#L164-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.diagonal_norm_rev!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.diagonal_norm_rev!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.diagonal_norm_rev!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diagonal_norm_rev!(points_bar, H_bar, root, points, degree)</code></pre><p>Reverse-mode differentiation of the weighted norm, <code>dot(H, H_bar)</code> with respect to the node coordinates in points.</p><p><strong>PRE</strong>: The cells in <code>root</code> must have their <code>data.moments</code>, <code>data.xref</code>, and <code>data.dx</code> fields set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/node_opt.jl#L173-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.diff_jacobi_poly-Union{Tuple{T}, Tuple{AbstractVector{T}, Any, Any, Int64}} where T" href="#CloudSBP.diff_jacobi_poly-Union{Tuple{T}, Tuple{AbstractVector{T}, Any, Any, Int64}} where T"><code>CloudSBP.diff_jacobi_poly</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dp = diff_jacobi_poly(x, alpha, beta, N)</code></pre><p>Evaluate the first derivative of a Jacobi Polynomial at the points <code>x</code>.  See  the companion code for <code>jacobipoly</code> for an explanation of the other parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L119-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.diff_proriol_poly!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64, Int64}} where T" href="#CloudSBP.diff_proriol_poly!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64, Int64}} where T"><code>CloudSBP.diff_proriol_poly!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_proriol_poly!(dP, x, y, z, i, j, k)</code></pre><p>Evaluate the derivatives of a Proriol orthogonal polynomial basis function on the right tetrahedron.  The arrays <code>x</code>,<code>y</code>, and <code>z</code> are the locations at which  to evaluate the polynomial, and the integers <code>i</code>,<code>j</code>, and <code>k</code> define the basis  function to evaluate.  The result is stored in <code>dP</code>.</p><p><em>Notes</em>: the derivatives are computed using the complex-step method (since there  are many outputs and only 3 inputs); therefore, a different method should be  used for verification of this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L271-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.diff_proriol_poly!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64}} where T" href="#CloudSBP.diff_proriol_poly!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64}} where T"><code>CloudSBP.diff_proriol_poly!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_proriol_poly!(dP, x, y, i, j)</code></pre><p>Evaluate the derivatives of a Proriol orthogonal polynomial basis function on the right triangle.  The arrays <code>x</code> and <code>y</code> give the locations at which to evaluate the polynomial, and the integers <code>i</code> and <code>j</code> define the basis function  to evaluate.  The result is stored in <code>dP</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L189-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.face_quadrature!-Union{Tuple{T}, Tuple{Dim}, Tuple{Any, Any, RegionTrees.HyperRectangle{Dim, T}, Any, Any, Int64}} where {Dim, T}" href="#CloudSBP.face_quadrature!-Union{Tuple{T}, Tuple{Dim}, Tuple{Any, Any, RegionTrees.HyperRectangle{Dim, T}, Any, Any, Int64}} where {Dim, T}"><code>CloudSBP.face_quadrature!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">face_quadrature!(xq, wq, rect, x1d, w1d, dir)</code></pre><p>Builds a tensor-product quadrature rule on a <code>Dim-1</code> hyperrectangle.  The  quadrature is returned in the updated arrays <code>xq</code> and <code>wq</code>, which hold the  locations and weights, respectively.  The rule is based on the one-dimensional  quadrature defined by <code>x1d</code> and <code>w1d</code>.  The <code>Dim-1</code> hyperrectuangle has a  boundary defined by <code>rect</code>, which has a unit normal in the Cartesian index  <code>dir</code>.  Note that <code>rect</code> is defined in <code>Dim</code> dimensions, and has <code>rect.widths [dir] = 0</code>, i.e. it has zero width in the <code>dir</code> direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/quadrature.jl#L30-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.get_bounding_box-Tuple{Any, Any}" href="#CloudSBP.get_bounding_box-Tuple{Any, Any}"><code>CloudSBP.get_bounding_box</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">box_center, box_dx = get_bounding_box(rect, x)</code></pre><p>For a given HyperRectangle <code>rect</code> and point cloud <code>x</code>, returns the bounding box center and lengths that enclose both <code>rect</code> and <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.get_complex_step-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Float32" href="#CloudSBP.get_complex_step-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Float32"><code>CloudSBP.get_complex_step</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_complex_step(T)</code></pre><p>returns an appropriate complex-step size for the given type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/utils.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.get_data-Tuple{Any, Any}" href="#CloudSBP.get_data-Tuple{Any, Any}"><code>CloudSBP.get_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">data = get_data(cell, child_indices)</code></pre><p>Returns a <code>CellData</code> struct based on the given <code>cell</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.get_neighbors-Tuple{RegionTrees.Cell, Any}" href="#CloudSBP.get_neighbors-Tuple{RegionTrees.Cell, Any}"><code>CloudSBP.get_neighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neighbors = get_neighbors(cell, side)</code></pre><p>Constructs a vector of all neighbors on the <code>side</code> boundary of leaf <code>cell</code>.</p><p>Based on the paper here: http://www.cs.umd.edu/~hjs/pubs/SameCVGIP89.pdf See also https://geidav.wordpress.com/2017/12/02/advanced-octrees-4-finding-neighbor-nodes/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/face.jl#L178-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.get_null_and_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.get_null_and_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.get_null_and_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">wp, Z, num_vars = get_null_and_part(root, xc, degree)</code></pre><p>Returns a vector of nullspaces, <code>Z</code>, and particular solutions, <code>wp</code>, for each  cell&#39;s quadrature problem.  Also returns the total number of degrees of  freedom.  Note that <code>wp</code> and <code>Z</code> are <code>Vector</code>s of <code>Vector</code> and <code>Matrix</code>,  respectively.</p><p><strong>PRE</strong>: The cells in <code>root</code> must have their <code>data.moments</code>, <code>data.xref</code>, and <code>data.dx</code> fields set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/norm.jl#L247-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.get_points_inside" href="#CloudSBP.get_points_inside"><code>CloudSBP.get_points_inside</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inside = get_points_inside(rect, points [, indices=[1:size(points,2)]])</code></pre><p>Returns the subset of integers from <code>indices</code> corresponding to points from  <code>points</code> that are inside the hyperrectangle <code>rect</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L170-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.indices_within_parent-Tuple{Any}" href="#CloudSBP.indices_within_parent-Tuple{Any}"><code>CloudSBP.indices_within_parent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">I = indices_within_parent(cell)</code></pre><p>Returns the Cartesian indices of <code>cell</code> with respect to its parent.  This  function assumes <code>cell</code> has a parent and will fail if it does not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/face.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.interface_interp-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Any, Any, Any}} where {Dim, T, Cell}" href="#CloudSBP.interface_interp-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Any, Any, Any}} where {Dim, T, Cell}"><code>CloudSBP.interface_interp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rl, Rr, x, w  = interface_interp(face, xc_left, xc_right, degree)</code></pre><p>Returns interpolation operators <code>Rl</code> and <code>Rr</code> from <code>xc_left</code> and <code>xc_right</code> to <code>x</code>, respectively, where <code>x</code> is the returned averaged center of the face <code>face</code>.  <code>w</code> is the weight associate with <code>face</code> (its area).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/dissipation.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.interface_interp-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Vararg{Any, 4}}} where {Dim, T, Cell}" href="#CloudSBP.interface_interp-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Vararg{Any, 4}}} where {Dim, T, Cell}"><code>CloudSBP.interface_interp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rl, Rr, x, w  = interface_interp(face, xc_left, xc_right, degree, levset
                                 [, fit_degree=degree])</code></pre><p>This version of the method is for planar interfaces that are cut by a level-set geometry defined by the function <code>levset</code>.  The optional kwarg <code>fit_degree</code> indicates the degree of the Bernstein polynomials used to approximate the level-set within the Algoim library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/dissipation.jl#L43-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.interface_skew_part-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Any, Any, Any}} where {Dim, T, Cell}" href="#CloudSBP.interface_skew_part-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Any, Any, Any}} where {Dim, T, Cell}"><code>CloudSBP.interface_skew_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sface = interface_skew_part(face, xc_left, xc_right, degree)</code></pre><p>Constructs the form</p><p><span>$\int_{\text{face}} V_i V_j d\Gamma$</span></p><p>where the integral is over the face <code>face</code> with unit normal in the coordinate direction <code>face.dir</code>.  The functions <span>$V_i$</span> and <span>$V_j$</span> can be regarded as degree <code>degree</code> basis functions at the nodes <code>i</code> and <code>j</code> within the stencil of the left and right cells, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/skew_part.jl#L99-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.interface_skew_part-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Vararg{Any, 4}}} where {Dim, T, Cell}" href="#CloudSBP.interface_skew_part-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Vararg{Any, 4}}} where {Dim, T, Cell}"><code>CloudSBP.interface_skew_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sface = interface_skew_part(face, xc_left, xc_right, degree, levset
                            [, fit_degree=degree])</code></pre><p>This version of the method is for planar interfaces that are cut by a level-set geometry defined by the function <code>levset</code>.  The optional kwarg <code>fit_degree</code> indicates the degree of the Bernstein polynomials used to approximate the level-set within the Algoim library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/skew_part.jl#L135-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.is_center_immersed-Union{Tuple{T}, Tuple{Dim}, Tuple{RegionTrees.HyperRectangle{Dim, T}, Function}} where {Dim, T}" href="#CloudSBP.is_center_immersed-Union{Tuple{T}, Tuple{Dim}, Tuple{RegionTrees.HyperRectangle{Dim, T}, Function}} where {Dim, T}"><code>CloudSBP.is_center_immersed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inside = is_center_immersed(rect, levset)</code></pre><p>Returns true if the <strong>center</strong> of <code>rect</code> is inside the level-set <code>levset</code>, that  is, phi(xc) &lt; 0.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.is_cut-Tuple{Any}" href="#CloudSBP.is_cut-Tuple{Any}"><code>CloudSBP.is_cut</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cut = is_cut(cell)</code></pre><p>Returns <code>false</code> if <code>cell</code> is not cut; note that a return of <code>true</code>, however,  only indicates that the cell <em>may</em> be cut.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.is_cut-Union{Tuple{Face{Dim, T, Cell}}, Tuple{Cell}, Tuple{T}, Tuple{Dim}} where {Dim, T, Cell}" href="#CloudSBP.is_cut-Union{Tuple{Face{Dim, T, Cell}}, Tuple{Cell}, Tuple{T}, Tuple{Dim}} where {Dim, T, Cell}"><code>CloudSBP.is_cut</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cut = is_cut(face)</code></pre><p>Returns <code>false</code> if <code>face</code> is not cut; note that a return of <code>true</code>, however,  only indicates that the face <em>may</em> be cut.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/face.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.is_cut-Union{Tuple{T}, Tuple{Dim}, Tuple{RegionTrees.HyperRectangle{Dim, T}, Function}} where {Dim, T}" href="#CloudSBP.is_cut-Union{Tuple{T}, Tuple{Dim}, Tuple{RegionTrees.HyperRectangle{Dim, T}, Function}} where {Dim, T}"><code>CloudSBP.is_cut</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cut = is_cut(rect, levset [, fit_degree=2])</code></pre><p>Returns true if the HyperRectangle <code>rect</code> is intersected by the level-set  <code>levset</code>, and returns false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.is_immersed-Tuple{Any}" href="#CloudSBP.is_immersed-Tuple{Any}"><code>CloudSBP.is_immersed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">im = is_immersed(cell)</code></pre><p>Returns <code>true</code> if cell is not cut and its center is immersed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.is_immersed-Union{Tuple{Face{Dim, T, Cell}}, Tuple{Cell}, Tuple{T}, Tuple{Dim}} where {Dim, T, Cell}" href="#CloudSBP.is_immersed-Union{Tuple{Face{Dim, T, Cell}}, Tuple{Cell}, Tuple{T}, Tuple{Dim}} where {Dim, T, Cell}"><code>CloudSBP.is_immersed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">im = is_immersed(face)</code></pre><p>Returns <code>true</code> if face is not cut and its center is immersed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/face.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.jacobi_poly!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Any, Any, Int64, AbstractVector{T}}} where T" href="#CloudSBP.jacobi_poly!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Any, Any, Int64, AbstractVector{T}}} where T"><code>CloudSBP.jacobi_poly!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobi_poly!(p, x, alpha, beta, N, work)</code></pre><p>Evaluate Jacobi polynomial at the points <code>x</code> and return in <code>p</code>.  Based on  JacobiP in Hesthaven and Warburton&#39;s nodal DG book.  <code>alpha</code> and <code>beta</code> are  parameters that define the type of Jacobi Polynomial (alpha + beta != 1).  <code>N</code>  is the polynomial degree, not the number of nodes.  The array <code>work</code> should be  twice the length of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.leaves_on_side-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Int64}} where {Data, Dim, T, L}" href="#CloudSBP.leaves_on_side-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Int64}} where {Data, Dim, T, L}"><code>CloudSBP.leaves_on_side</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leaves = leaves_on_side(cell, side)</code></pre><p>Returns a Vector of leaves on boundary index <code>side</code> of given root <code>cell</code>.  If  <code>cell</code> is nothing, the Vector is returned empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/face.jl#L145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.lg_nodes" href="#CloudSBP.lg_nodes"><code>CloudSBP.lg_nodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">x, w = lg_nodes(N [, T=Float64])</code></pre><p>Computes the Legendre-Gauss (LG) quadrature nodes <code>x</code> and weights <code>w</code> on the  interval [-1,1].  The LG nodes are the zeros of P<em>N(x), where P</em>N(x) denotes  the Nth Legendre polynomial.</p><p>Julia version adapted from Matlab code written by Greg von Winckel - 02/25/2004 Contact: gregvw@chtm.unm.edu </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.lgl_nodes" href="#CloudSBP.lgl_nodes"><code>CloudSBP.lgl_nodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">x, w = lgl_nodes(N [, T=Float64])</code></pre><p>Computes the Legendre-Gauss-Lobatto (LGL) quadrature nodes <code>x</code> and weights <code>w</code>  on the interval [-1,1].  The LGL nodes are the zeros of (1-x^2)*P&#39;<em>N(x), where  P</em>N(x) denotes the Nth Legendre polynomial.</p><p>Julia version adapted from Matlab code written by Greg von Winckel - 04/17/2004 Contact: gregvw@chtm.unm.edu</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.make_compatible!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.make_compatible!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.make_compatible!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_compatible!(E, H, cell, xc, degree)</code></pre><p>Modifies the SBP symmetric operator <code>E</code> for cell <code>cell</code> such that it is compatible with the diagonal norm <code>H</code>.  The operators are defined over the nodes <code>xc</code> and are for a degree <code>degree</code> exact SBP first-derivative operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/symmetric_part.jl#L249-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.mark_cut_cells!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Function}} where {Data, Dim, T, L}" href="#CloudSBP.mark_cut_cells!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Function}} where {Data, Dim, T, L}"><code>CloudSBP.mark_cut_cells!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mark_cut_cells!(root, levset)</code></pre><p>Identifies cells in the tree <code>root</code> that <em>may be</em> cut be the level-set <code>levset</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.mark_cut_faces!-Tuple{Any, Any}" href="#CloudSBP.mark_cut_faces!-Tuple{Any, Any}"><code>CloudSBP.mark_cut_faces!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mark_cut_faces!(faces, levset)</code></pre><p>Identifies faces in the list <code>faces</code> that <em>may be</em> cut be the level-set levset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mesh.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.mass_matrix-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.mass_matrix-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.mass_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">M = mass_matrix(root, xc, degree)</code></pre><p>Returns the DGD mass matrix for degree <code>degree</code> based on the mesh in the tree  <code>root</code> and the centers in <code>xc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mass.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.mass_obj-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}" href="#CloudSBP.mass_obj-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.mass_obj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">obj = mass_obj(root, xc, xc_init, dist_ref, H_tol, mu, degree)</code></pre><p>Compute the objective that seeks to minimize the change in the node locations while ensuring a positive lumped mass matrix.  <code>root</code> is the mesh, <code>xc</code> are the  nodes being varied, and <code>xc_init</code> are the initial node locations. <code>dist_ref</code> are reference lengths, and <code>H_tol</code> is an array of tolerances for the lumped mass  value at each node; that is, <code>sum_{j} M[i,j] &gt;= H_tol[i]</code> for the constraint to  be satisfied.  Finally, <code>mu</code> scales the regularization term, and <code>degree</code> is  the target exactness of the rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mass.jl#L128-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.mass_obj_grad!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}" href="#CloudSBP.mass_obj_grad!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.mass_obj_grad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mass_obj_grad!(g, root, xc, xc_init, dist_ref, H_tol, mu, degree)</code></pre><p>Computes the derivative of <code>mass_obj</code> with respect to <code>xc</code>.  See <code>mass_obj</code> for and explanation of the remaining parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mass.jl#L163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.mass_row_sums!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.mass_row_sums!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.mass_row_sums!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mass_row_sums!(lumped_mass, root, xc, degree)</code></pre><p>Fills the array <code>lumped_mass</code> with the sum of the rows (or columns) of the  symmetric DGD mass matrix of degree <code>degree</code> based on the cloud <code>xc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mass.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.mass_row_sums_rev!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.mass_row_sums_rev!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.mass_row_sums_rev!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mass_row_sums_rev!(xc_bar, lumped_mass_bar, root, xc, degree)</code></pre><p>Reverse-mode differentiation of the weighted norm, <code>dot(lumped_mass, lumped_mass_bar)</code> with respect to the node coordinates in points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mass.jl#L88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.max_leaf_stencil-Tuple{Any}" href="#CloudSBP.max_leaf_stencil-Tuple{Any}"><code>CloudSBP.max_leaf_stencil</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">max_stencil = max_leaf_stencil(root)</code></pre><p>Returns the largest stencil (i.e. number of points used for DGD basis) over all  leaves in the mesh defined by <code>root</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mesh.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.monomial_basis!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, Val{1}}} where T" href="#CloudSBP.monomial_basis!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, Val{1}}} where T"><code>CloudSBP.monomial_basis!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">monomial_basis!(V, degree, x, Val(N))</code></pre><p>This method computes the monomial basis of total degree <code>degree</code> at the points  <code>x</code>.  The type parameter <code>N</code> is used to select the appropriate spatial  dimension.  These methods are useful for testing, but given the  ill-conditioning of the corresponding Vandermonde matrix, they should not be  used to construct the DGD basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L415-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.monomial_basis_derivatives!-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, AbstractMatrix{T}, Val{1}}} where T" href="#CloudSBP.monomial_basis_derivatives!-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, AbstractMatrix{T}, Val{1}}} where T"><code>CloudSBP.monomial_basis_derivatives!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">monomial_basis_derivatives!(dV, degree, x, Val(N))</code></pre><p>This method and its variants compute the first derivatives of monomial basis  of total degree <code>degree</code> at the points <code>x</code>.  The type parameter <code>N</code> is used to  select the appropriate spatial dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L460-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.neighbor_of_greater_or_equal_size-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Int64}} where {Data, Dim, T, L}" href="#CloudSBP.neighbor_of_greater_or_equal_size-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Int64}} where {Data, Dim, T, L}"><code>CloudSBP.neighbor_of_greater_or_equal_size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nbr = neighbor_of_greater_or_equal_size(cell, side)</code></pre><p>Returns the cell on boundary index <code>side</code> of <code>cell</code> that is of the same size or  larger than <code>cell</code>.  Returns <code>nothing</code>` if no such neighbor exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/face.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.num_leaves-Tuple{Any}" href="#CloudSBP.num_leaves-Tuple{Any}"><code>CloudSBP.num_leaves</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n = num_leaves(root)</code></pre><p>Returns the total number of leaves in the given <code>root</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.number_immersed-Tuple{Any}" href="#CloudSBP.number_immersed-Tuple{Any}"><code>CloudSBP.number_immersed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">count = number_immersed(faces)</code></pre><p>Returns the number of <code>faces</code> that are definitely immersed.  Note that this is  a lower bound, since the immeresed check is conservative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mesh.jl#L197-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.obj_norm-Union{Tuple{T2}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, AbstractArray{Vector{T2}, 1}, AbstractArray{Matrix{T2}, 1}, AbstractVector{T2}, T2, Int64}} where {Data, Dim, T, L, T2}" href="#CloudSBP.obj_norm-Union{Tuple{T2}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, AbstractArray{Vector{T2}, 1}, AbstractArray{Matrix{T2}, 1}, AbstractVector{T2}, T2, Int64}} where {Data, Dim, T, L, T2}"><code>CloudSBP.obj_norm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">obj = obj_norm(root, wp, Z, y, rho, num_nodes)</code></pre><p>Compute the objective to maximize the minimum norm.  <code>root</code> is the mesh, which  is mostly needed to known the stencil for each cell.  <code>wp</code> is a vector of  vectors holding the particular solution for each cell, and <code>Z</code> is the nullspace  for each cell&#39;s problem.</p><p><strong>NOTE</strong>: this objective is deprecated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/node_opt.jl#L210-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.obj_norm_grad!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, AbstractArray{Vector{T}, 1}, AbstractArray{Matrix{T}, 1}, AbstractVector{T}, T, Int64}} where {Data, Dim, T, L}" href="#CloudSBP.obj_norm_grad!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, AbstractArray{Vector{T}, 1}, AbstractArray{Matrix{T}, 1}, AbstractVector{T}, T, Int64}} where {Data, Dim, T, L}"><code>CloudSBP.obj_norm_grad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">obj_norm_grad!(g, root, wp, Z, y, num_nodes)</code></pre><p>Compute the gradient of the objective to maximize the minimum norm.  <code>root</code> is  the mesh, which is mostly needed to known the stencil for each cell.  <code>wp</code> is a  vector of vectors holding the particular solution for each cell, and <code>Z</code> is the  nullspace for each cell&#39;s problem.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/node_opt.jl#L245-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.obj_slice-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 7}}} where {Data, Dim, T, L}" href="#CloudSBP.obj_slice-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 7}}} where {Data, Dim, T, L}"><code>CloudSBP.obj_slice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">obj_slice(root, xc, degree, H_tol, mu, dist_ref, node, pert)</code></pre><p>Returns an array of objective function values along a slice based on perturbing  node <code>node</code> in the direction <code>pert</code>.  Used for visualizing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/node_opt.jl#L625-L630">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.opt_norm!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}" href="#CloudSBP.opt_norm!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.opt_norm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">H = opt_norm!(root, xc, degree, H_tol, mu, dist_ref, max_rank)</code></pre><p>Finds an approximate minimizer for the objective <code>penalty</code> with respect to the node coordinates <code>xc</code> and based on the background mesh <code>root</code>.  Once an approximate solution is found, the corresponding <code>H</code> norm is returned; note  that the <code>xc</code> coordinates are altered in the process.  The parameter <code>max_rank</code> determines the rank of the approximate Jacobian of the norm with respective to  the nodes, and this approximate Jacobian is used to form an approximate inverse Hessian.  See <code>penalty</code> for explanations of the other parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/node_opt.jl#L539-L549">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.output_pyplot-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}" href="#CloudSBP.output_pyplot-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}"><code>CloudSBP.output_pyplot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">xplot, uplot = output_pyplot(root, xc, degree, u [, num_pts=degree+1])</code></pre><p>Outputs &quot;meshgrid&quot; type data for each cell in <code>root</code> for plotting the contours  of the state <code>u</code> using Matplotlib.  The solution is of degree <code>degree</code> and  <code>num_pts</code> samples are used in each direction on each cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/output.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.output_vtk-Union{Tuple{L}, Tuple{T}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, 2, T, L}, Any, Any, Any}} where {Data, T, L}" href="#CloudSBP.output_vtk-Union{Tuple{L}, Tuple{T}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, 2, T, L}, Any, Any, Any}} where {Data, T, L}"><code>CloudSBP.output_vtk</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vtk = output_vtk(root, xc, degree, u [, num_pts=degree+1,
                 filename=&quot;solution&quot;, save=true])</code></pre><p>Creates a VTK file for a scalar solution based on the mesh in <code>root</code>, the points <code>xc</code>, and the solution coefficients in <code>u</code>.  The reconstruction used is of degree <code>degree</code>, although only the solution is only interpolated to the  cell vertices at this time (i.e. the cell&#39;s themselves are not high-order in  Paraview).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/output.jl#L88-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.penalty-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}" href="#CloudSBP.penalty-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.penalty</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">obj = penalty(root, xc, xc_init, dist_ref, H_tol, mu, degree)</code></pre><p>Compute the objective that seeks to minimize the change in the node locations while ensuring positive quadrature weights.  <code>root</code> is the mesh, <code>xc</code> are the  nodes being varied, and <code>xc_init</code> are the initial node locations. <code>dist_ref</code> are reference lengths, and <code>H_tol</code> is an array of tolerances for the quadrature  weight at each node; that is, <code>H[i] &gt;= H_tol[i]</code> for the constraint to be  satisfied.  Finally, <code>mu</code> scales the regularization term, and <code>degree</code> is the  target exactness of the rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/node_opt.jl#L313-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.penalty_grad!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}" href="#CloudSBP.penalty_grad!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}"><code>CloudSBP.penalty_grad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">penalty_grad!(g, root, xc, xc_init, dist_ref, H_tol, mu, degree)</code></pre><p>Computes the derivative of <code>penalty</code> with respect to <code>xc</code>.  See <code>penalty</code> for an explanation of the remaining parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/node_opt.jl#L349-L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.point_data_vtk-Tuple{Any, Any, Any}" href="#CloudSBP.point_data_vtk-Tuple{Any, Any, Any}"><code>CloudSBP.point_data_vtk</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point_data_vtk(xc, data, label [, filename=&quot;point_data&quot;])</code></pre><p>Writes the points <code>xc</code> to the file <code>&quot;point_data&quot;</code>.  <code>data</code> is a (possibly  empty) <code>Vector</code> of arrays that holds data to be associated with each node, and  <code>label</code> is a label associated with it.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># write data to plot the norm and its sign at each node
point_data_vtk(xc, [abs.(H), sign.(H)], [&quot;norm-mag&quot;, &quot;norm-sign&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/output.jl#L59-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.points_vtk-Tuple{Any}" href="#CloudSBP.points_vtk-Tuple{Any}"><code>CloudSBP.points_vtk</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">points_vtk(xc [, filename=&quot;points&quot;])</code></pre><p>Writes the cloud points <code>xc</code> to the file &quot;points.vtu&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/output.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.poly_basis!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, AbstractVector{T}, Val{1}}} where T" href="#CloudSBP.poly_basis!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, AbstractVector{T}, Val{1}}} where T"><code>CloudSBP.poly_basis!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_basis!(V, degree, x, work, Val(N))</code></pre><p>This method and its variants compute the approporiate polynomial basis of total  degree <code>degree</code> at the points <code>x</code>.  The type parameter <code>N</code> is used to select  the appropriate spatial dimension.  The size of <code>work</code> should be <code>N+1</code> times  the number of rows in <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L312-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.poly_basis_derivatives!-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, AbstractMatrix{T}, Val{1}}} where T" href="#CloudSBP.poly_basis_derivatives!-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, AbstractMatrix{T}, Val{1}}} where T"><code>CloudSBP.poly_basis_derivatives!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_basis_derivatives!(dV, degree, x, Val(N))</code></pre><p>This method and its variants compute the first derivatives of polynomial basis  of total degree <code>degree</code> at the points <code>x</code>.  The type parameter <code>N</code> is used to  select the appropriate spatial dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L367-L373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.proriol_poly!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64, Int64, AbstractVector{T}}} where T" href="#CloudSBP.proriol_poly!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64, Int64, AbstractVector{T}}} where T"><code>CloudSBP.proriol_poly!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">proriol_poly!(p, x, y, z, i, j, k, work)</code></pre><p>Evaluate a Proriol orthogonal polynomial basis function on the right  tetrahedron and return in array <code>p</code>.  The arrays <code>x</code>,<code>y</code>, and <code>z</code> are the  locations at which to evaluate the polynomial, and the integers <code>i</code>,<code>j</code>, and  <code>k</code> define the basis function to evaluate; see Hesthaven and Warburton&#39;s Nodal  DG book, for example, for a reference.  The <code>work</code> array should be at least 4  times the length of <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L234-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.proriol_poly!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64, AbstractVector{T}}} where T" href="#CloudSBP.proriol_poly!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64, AbstractVector{T}}} where T"><code>CloudSBP.proriol_poly!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">proriol_poly!(p, x, y, i, j, work)</code></pre><p>Evaluate a Proriol orthogonal polynomial basis function on the right triangle  and return in array <code>p</code>.  The arrays <code>x</code> and <code>y</code> give the locations at which to  evaluate the polynomial, and the integers <code>i</code> and <code>j</code> define the basis function  to evaluate; see Hesthaven and Warburton&#39;s Nodal DG book, for example, for a  reference.  <code>work</code> is a vector that should be 3 times the length of p.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L162-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.push_new_face!-Union{Tuple{T}, Tuple{CloudSBP.BoundaryOperator{T}, Any, Any, Any}} where T" href="#CloudSBP.push_new_face!-Union{Tuple{T}, Tuple{CloudSBP.BoundaryOperator{T}, Any, Any, Any}} where T"><code>CloudSBP.push_new_face!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">xq, nrm, dof, prj = push_new_face!(bndry, Dim, num_nodes, num_quad)</code></pre><p>Creates new memory at the end of the fields in the given <code>BoundaryOperator</code> and  returns references to the newly created arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/first_derivative.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.quadrature!-Union{Tuple{T}, Tuple{Dim}, Tuple{Any, Any, RegionTrees.HyperRectangle{Dim, T}, Any, Any}} where {Dim, T}" href="#CloudSBP.quadrature!-Union{Tuple{T}, Tuple{Dim}, Tuple{Any, Any, RegionTrees.HyperRectangle{Dim, T}, Any, Any}} where {Dim, T}"><code>CloudSBP.quadrature!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quadrature!(xq, wq, rect, x1d, w1d)</code></pre><p>Builds a tensor-product quadrature for the domain defined by <code>rect</code> using the  one-dimensional quadratrure defined by the nodes <code>x1d</code> and the weights <code>w1d</code>.   The tensor-product quadrature nodes and weights are given by <code>xq</code> and <code>wq</code>,  respectively.  These are stored in 2-d and 1-d array formats.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/quadrature.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.refine_on_levelset!-NTuple{4, Any}" href="#CloudSBP.refine_on_levelset!-NTuple{4, Any}"><code>CloudSBP.refine_on_levelset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine_on_levelset!(root, points, levset, min_widths)</code></pre><p>Refines the leaves in <code>root</code> until each cut leaf is less than <code>min_widths</code> dimensions.  The array of <code>points</code> are needed so that refined leaves have the  necessary data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L256-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.refine_on_points!-Tuple{Any, Any}" href="#CloudSBP.refine_on_points!-Tuple{Any, Any}"><code>CloudSBP.refine_on_points!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine_on_points!(root, points)</code></pre><p>Refines the tree <code>root</code> until each cell has at most one of the points in  <code>points</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L243-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.set_xref_and_dx!-Tuple{Any, Any}" href="#CloudSBP.set_xref_and_dx!-Tuple{Any, Any}"><code>CloudSBP.set_xref_and_dx!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_xref_and_dx!(root, points)</code></pre><p>For each <code>leaf</code> in <code>root</code>, finds a reference position and reference scale for <code>leaf.data.xref</code> and <code>leaf.data.dx</code>, respectively.  The reference position is, roughly, the average of the coordinates <code>points[:,leaf.data.points]</code> and the  <code>leaf</code>&#39;s boundary.  The reference scale is the extent of the coordinates and  boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mesh.jl#L91-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.skew_operator-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 5}}} where {Data, Dim, T, L}" href="#CloudSBP.skew_operator-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 5}}} where {Data, Dim, T, L}"><code>CloudSBP.skew_operator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">S = skew_operator(root, ifaces, bfaces, xc, levset, degree
                  [, fit_degree=degree, use_cell_wts=true])</code></pre><p>Constructs the skew-symmetric part of a (global), first-derivative SBP  operator.  The integration mesh is given by <code>root</code> and <code>xc</code> defines the cloud  of distributed nodes where the degrees of freedom are stored.  <code>ifaces</code> is an  array of interfaces and <code>bfaces</code> is an array of boundary faces corresponding to <code>root</code>.  <code>levset</code> is a function that defines the immersed geomtry, if any.  The skew-symmetric matrix is degree <code>degree</code> exact.  Finally, <code>fit_degree</code> gives  the polynomial degree of the Bernstein polynomials used to approximate <code>levset</code>  by the Algoim library.  If <code>use_cell_wts</code> is <code>true</code>, the cell-based norm is formed using the data in <code>cell.data.wts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/skew_part.jl#L170-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.solve_min_norm!-Tuple{Any, Any, Any}" href="#CloudSBP.solve_min_norm!-Tuple{Any, Any, Any}"><code>CloudSBP.solve_min_norm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_min_norm!(w, V, b)</code></pre><p>Finds the minimum norm solution to <code>transpose(V) w = b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/utils.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.solve_min_norm_diff!-NTuple{5, Any}" href="#CloudSBP.solve_min_norm_diff!-NTuple{5, Any}"><code>CloudSBP.solve_min_norm_diff!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_min_norm_diff!(w, dw, V, dV, b)</code></pre><p>Forward mode of <code>solve_min_norm!</code> treating <code>b</code> as constant.  This is useful for verifying the reverse mode implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/utils.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.solve_min_norm_rev!-NTuple{4, Any}" href="#CloudSBP.solve_min_norm_rev!-NTuple{4, Any}"><code>CloudSBP.solve_min_norm_rev!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_min_norm_rev!(V_bar, w_bar, V, b)</code></pre><p>Reverse mode of <code>solve_min_norm!</code>.  On entry, <code>w_bar</code> holds the derivatives of the objective w.r.t. the weights.  On exit, <code>V_bar</code> holds the derivatives of the objective w.r.t. the matrix <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/utils.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.solve_norm!-NTuple{4, Any}" href="#CloudSBP.solve_norm!-NTuple{4, Any}"><code>CloudSBP.solve_norm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">H, success = solve_norm!(root, xc, degree, H_tol [, verbose=false])</code></pre><p>Attempts to solve the norm-inequality problem using the interior-point method  implemented in the Tulip.jl package.  <code>root</code> defines the background mesh, <code>xc</code>  are the nodes, degree is the target degree of the norm, and <code>H_tol</code> holds the  lower bound on the norm entries.  If <code>verbose</code> is <code>true</code>, the <code>&quot;OutputLevel&quot;</code>  attribute of Tulip is set to 1 (so more output is provided).  The method  returns the diagonal norm, <code>H</code>, and a <code>Bool</code>, <code>success</code>, that indicates whether  Tulip was successful (<code>success=true</code>) or not.  If the problem was not  successfully solved, <code>H</code> is returned with the minimum-norm quadrature weights  (which likely have some negative weights).</p><p><strong>PRE</strong>: The cells in <code>root</code> must have their <code>data.moments</code>, <code>data.xref</code>, and <code>data.dx</code> fields set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/norm.jl#L313-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.stencil_stats-Tuple{CloudSBP.Mesh}" href="#CloudSBP.stencil_stats-Tuple{CloudSBP.Mesh}"><code>CloudSBP.stencil_stats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">max_stencil, avg_stencil = stencil_stats(mesh)</code></pre><p>Returns the maximum cell stencil size and the average stencil size.  Only cells that are non immersed are included, since immersed cells should have empty  stencils.</p><p><strong>PRE</strong>: The cells in <code>mesh</code> must have their stencils defined; this should be  the case if a high-level mesh construction was used (e.g. <code>build_mesh</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/mesh.jl#L281-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.symmetric_operator-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 5}}} where {Data, Dim, T, L}" href="#CloudSBP.symmetric_operator-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 5}}} where {Data, Dim, T, L}"><code>CloudSBP.symmetric_operator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">E = symmetric_operator(root, ifaces, bfaces, xc, levset, degree
                       [, fit_degree=degree])</code></pre><p>Constructs the symmetric part of a (global), first-derivative SBP operators as an <code>SVector</code> of sparse matrices; only the symmetric part is stored. The integration mesh is given by <code>root</code> and <code>xc</code> defines the cloud of distributed nodes where the degrees of freedom are stored.  <code>ifaces</code> is an array of intefaces and <code>bfaces</code> is an array of boundary faces corresponding to <code>root</code>. <code>levset</code> is a function that defines the immersed geomtry, if any.  The symmetric matrix is degree <code>degree</code> exact.  Finally, <code>fit_degree</code> gives the polynomial degree of the Bernstein polynomials used to approximate <code>levset</code> by the Algoim library.</p><p><strong>Note</strong>: The sparse matrices are not useful for much other than verifying the accuracy of the global skew-symmetric parts; this is because we do not distinguish different boundaries, nor do we provide the decomposition of the symmetric part into interpolation operators and face quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/symmetric_part.jl#L428-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.tensor_basis!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, AbstractVector{T}, Val{1}}} where T" href="#CloudSBP.tensor_basis!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, AbstractVector{T}, Val{1}}} where T"><code>CloudSBP.tensor_basis!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tensor_basis!(V, degree, x, Val(N))</code></pre><p>This method computes the tensor-product basis of degree <code>degree</code> at the points  <code>x</code>.  The type parameter <code>N</code> is used to select the appropriate spatial  dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/orthopoly.jl#L514-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CloudSBP.unsteady_vtk-Union{Tuple{L}, Tuple{T}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, 2, T, L}, Vararg{Any, 4}}} where {Data, T, L}" href="#CloudSBP.unsteady_vtk-Union{Tuple{L}, Tuple{T}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, 2, T, L}, Vararg{Any, 4}}} where {Data, T, L}"><code>CloudSBP.unsteady_vtk</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unsteady_vtk(root, xc, degree, t, sol [, num_pts=degree+1,
             filename=&quot;unsteady&quot;])</code></pre><p>Writes a Paraview collection in order to visualizae an unsteady solution.  The solution at time <code>t[k]</code> is stored in <code>sol[:,k]</code>.  See <code>output_vtk</code> for an explanation of the other inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/output.jl#L141-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegionTrees.needs_refinement-Tuple{CloudSBP.LevelSetRefinery, Any}" href="#RegionTrees.needs_refinement-Tuple{CloudSBP.LevelSetRefinery, Any}"><code>RegionTrees.needs_refinement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This method is for determining if cut cells need further refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L204-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegionTrees.needs_refinement-Tuple{CloudSBP.PointRefinery, Any}" href="#RegionTrees.needs_refinement-Tuple{CloudSBP.PointRefinery, Any}"><code>RegionTrees.needs_refinement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine = needs_refinement(r, cell)</code></pre><p>Returns true if <code>cell</code> has more than one point in it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegionTrees.refine_data-Tuple{CloudSBP.LevelSetRefinery, RegionTrees.Cell, Any}" href="#RegionTrees.refine_data-Tuple{CloudSBP.LevelSetRefinery, RegionTrees.Cell, Any}"><code>RegionTrees.refine_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This method, which is almost identical to the above method, is used when  refining cells that are cut by a given levelset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L232-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RegionTrees.refine_data-Tuple{CloudSBP.PointRefinery, RegionTrees.Cell, Any}" href="#RegionTrees.refine_data-Tuple{CloudSBP.PointRefinery, RegionTrees.Cell, Any}"><code>RegionTrees.refine_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">child_data = refine_data(r, cell, indices)</code></pre><p>Returns data for child of <code>cell</code> with <code>indices</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jehicken/CloudSBP.jl/blob/0c2d18a87b26e5a6fc3c8146f5b0c64dee09d82c/src/cell.jl#L220-L224">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 6 September 2024 17:05">Friday 6 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
