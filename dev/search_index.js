var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CloudSBP","category":"page"},{"location":"#CloudSBP","page":"Home","title":"CloudSBP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CloudSBP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CloudSBP]","category":"page"},{"location":"#CloudSBP.BoundaryOperator","page":"Home","title":"CloudSBP.BoundaryOperator","text":"Data for integrals on boundaries\n\nEach boundary condition can be associated with a BoundaryOperator, which  holds data needed to compute integrals over the relevant subset of the  boundary.  This data is grouped by faces, since each face may require a  different number of quadrature points or have a different sized stencil.  If  f denotes the index of some face, then xq_face[f][:,q] is the qth  quadrature point on face; nrm_face[f][:,q] is the quadrature-weighted outward  facing normal at xq_face[f][:,q]; dof_face[f][i] is global DOF index  associated with the local interpolation index i, and; prj_face[f][q,:] is  the interpolation operator from the local degrees of freedom to quadrature node  q.\n\n\n\n\n\n","category":"type"},{"location":"#CloudSBP.BoundaryOperator-Tuple{Type}","page":"Home","title":"CloudSBP.BoundaryOperator","text":"E = BoundaryOperator(T)\n\nReturns a BoundaryOperator with empty arrays.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.CellData","page":"Home","title":"CloudSBP.CellData","text":"Data associated with a RegionTree Cell.\n\n\n\n\n\n","category":"type"},{"location":"#CloudSBP.Dissipation","page":"Home","title":"CloudSBP.Dissipation","text":"Face-based dissipation operator\n\nw_face are the interface areas, x_face are the face centers, R_left and  R_right are interpolation operators to the faces.\n\n\n\n\n\n","category":"type"},{"location":"#CloudSBP.Face","page":"Home","title":"CloudSBP.Face","text":"Struct for interfaces and boundary faces of cells.\n\n\n\n\n\n","category":"type"},{"location":"#CloudSBP.Face-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Int64, StaticArraysCore.SVector{Dim, T}, StaticArraysCore.SVector{Dim, T}}, Tuple{Int64, StaticArraysCore.SVector{Dim, T}, StaticArraysCore.SVector{Dim, T}, Union{Nothing, Cell}}, Tuple{Int64, StaticArraysCore.SVector{Dim, T}, StaticArraysCore.SVector{Dim, T}, Union{Nothing, Cell}, Union{Nothing, Cell}}} where {Dim, T, Cell}","page":"Home","title":"CloudSBP.Face","text":"f = Face(dir, origin, widths [, data=nothing])\n\nConstruct a face with normal direction index dir, with corner at origin,  and having widths dimensions. \n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.LevelSetRefinery","page":"Home","title":"CloudSBP.LevelSetRefinery","text":"r = LevelSetRefinery(point_subset)\n\nUsed during to refine the mesh around a given level-set.  Refines until the cut  cells are less than r.min_widths dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#CloudSBP.Mesh","page":"Home","title":"CloudSBP.Mesh","text":"Mesh data structure\n\n\n\n\n\n","category":"type"},{"location":"#CloudSBP.PointRefinery","page":"Home","title":"CloudSBP.PointRefinery","text":"r = PointRefinery(point_subset)\n\nUsed during mesh refinement with respect to a given point cloud; see RegionTree  documentation for addition information.\n\n\n\n\n\n","category":"type"},{"location":"#CloudSBP.SBP","page":"Home","title":"CloudSBP.SBP","text":"Summation-by-parts first derivative operator\n\nS[d] holds the skew-symmetric part for direction d and E[:] holds BoundaryOperators that define the symmetric part.\n\n\n\n\n\n","category":"type"},{"location":"#CloudSBP.add_face_to_boundary!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{CloudSBP.BoundaryOperator{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 4}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.add_face_to_boundary!","text":"add_face_to_boundary!(bndry, cell, xc, degree, levset, levset_grad!\n                      [, fit_degree=degree])\n\nThis version of the method is for faces that are the intersection between the level-set levset(x)=0 and the cell cell.  In addition to the level-set, this function needs a function that can compute the gradient of the level-set, levset_grad!(g, x) which returns the gradient at x in the array g.  As usual, fit_degree indicates the degree of the Bernstein polynomials used to  approximate the level-set within the Algoim library.\n\nNOTE: we use 2*degree+1 nodes in each direction for the surface quadrature, since it must integrate the normal in addition to the flux.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.add_face_to_boundary!-Union{Tuple{T}, Tuple{CloudSBP.BoundaryOperator{T}, Any, Any, Any}} where T","page":"Home","title":"CloudSBP.add_face_to_boundary!","text":"add_face_to_boundary!(bndry, face, xc, degree)\n\nComputes the quadrature points, normal vector, degrees of freedom, and  interpolation operator for the face face and adds this data to the given  BoundaryOperator, bndry.  xc are the locations of the nodes in the  stencil of face, and degree determines the order of accuracy of the  quadrature (2*degree+1) and the interpolation.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.add_face_to_boundary!-Union{Tuple{T}, Tuple{CloudSBP.BoundaryOperator{T}, Vararg{Any, 4}}} where T","page":"Home","title":"CloudSBP.add_face_to_boundary!","text":"add_face_to_boundary!(bndry, face, xc, degree, levset [, fit_degree=degree])\n\nThis version of the method is for planar boundary faces that are cut by the level-set geometry defined by the function levset.  The optional kwarg  fit_degree indicates the degree of the Bernstein polynomials used to  approximate the level-set within the Algoim library.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.apply_approx_inverse!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.apply_approx_inverse!","text":"apply_approx_inverse!(p, g, root, xc, dist_ref, H_tol, mu, degree, max_rank)\n\nFinds a low-rank approximation to the inverse Hessian of the objective penalty, and applies this to -g to get a search direction p.  The background mesh is root, xc are the nodes/points, dist_ref is an array of reference distances for each node, mu is the regularization parameter, degree is the target degree.  The rank of the approximation is controlled by  max_rank.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.boundary_operators-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.boundary_operators","text":"E = boundary_operators(root, bc_map, bfaces, xc, levset, levset_grad!, \n                       degree [, fit_degree=degree])\n\nGenerates a set of BoundaryOperators for each of the 2*Dim planar boundary as well as the immersed surface within the domain of the root cell root. bc_map is a Dictionary that maps boundaries to boundary conditions; the key used for a planar boundaries is its side index:\n\n1 – EAST (root.boundary.origin[1])\n2 – WEST (root.boundary.origin[1] + root.boundary.width[1])\n3 – SOUTH (root.boundary.origin[2])\n4 – NORTH (root.boundary.origin[2] + root.boundary.width[2])\n5 – BOTTOM (root.boundary.origin[3])\n6 – TOP (root.boundary.origin[3] + root.boundary.width[3])\n\nThe key for the immersed surface is the string \"ib\".  All the planar boundary faces are stored in bfaces.  The DOF coordinates are given by xc. The immersed surface is defined by levset(x) = 0, and the gradient of this level set is g after calling levset_grad!(g,x).  The formal polynomial accuracy of the boundary operator is degree, while fit_degree gives the degree of the Bernstein polynomial used by Algoim to fit levset.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.boundary_sym_part-NTuple{4, Any}","page":"Home","title":"CloudSBP.boundary_sym_part","text":"E = boundary_sym_part(face, xc, degree, levset [, fit_degree=degree])\n\nThis version of the method is for planar boundary faces that are cut by the level-set geometry defined by the function levset.  The optional kwarg  fit_degree indicates the degree of the Bernstein polynomials used to  approximate the level-set within the Algoim library.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.boundary_sym_part-Tuple{Any, Any, Any}","page":"Home","title":"CloudSBP.boundary_sym_part","text":"E = boundary_sym_part(face, xc, degree)\n\nReturns the symmetric boundary form \n\nint_textface V_i V_j n_\textdir dGamma\n\nwhere the integral is over the face face with unit normal in the coordinate direction face.dir.  The functions V_i and V_j can be regarded as degree degree basis functions at the nodes i and j within the stencil of the cell whose stencil's coordinates are xc.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.boundary_sym_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.boundary_sym_part","text":"E = boundary_sym_part!(cell, xc, degree, levset [, fit_degree=degree])\n\nThis version of the method is for faces that are the intersection between the level-set levset(x)=0 and the cell cell.  As usual, fit_degree indicates the degree of the Bernstein polynomials used to approximate the level-set within the Algoim library.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.build_boundary_face-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Int64, RegionTrees.Cell{Data, Dim, T, L}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.build_boundary_face","text":"f = build_boundary_face(dir, cell)\n\nConstruct a boundary face with normal direction index dir having adjacent  element cell.  With this constructor, dir can be negative.  For example,  dir=1 is an East face, while dir=-1 is a West face.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.build_boundary_faces-Union{Tuple{RegionTrees.Cell{Data, Dim, T, L}}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.build_boundary_faces","text":"faces = build_boundary_faces(root)\n\nCreates an array of boundary faces of the tree root.  Boundary faces are  faces of the leaves of root that touch the the East, West, North, ...etc  sides of root.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.build_cell_stencils!-Tuple{Any, Any, Any}","page":"Home","title":"CloudSBP.build_cell_stencils!","text":"build_cell_stencils!(mesh, points, degree [, tol=5*10^degree, \n                     max_iter=2*degree+1])\n\nThis method loops over the cells in mesh and constructs the stencil for  each.  The stencil is based on the nodes points and the polynomial degree.   The function also determines the cell reference dimensions for affine scaling  of the Vandermonde matrix.  See build_nn_stencils! for an explanation of  tol and max_iter.\n\nNOTE: If you want a degree p SBP operator, set degree=2*p-1 so that the  stencil is sufficiently large for the diagonal mass matrix.\n\nTODO: At present this is just a front-end for build_nn_stencils!.  In the future we may want an input that allows for different stencil constructions.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.build_face-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Int64, RegionTrees.Cell{Data, Dim, T, L}, RegionTrees.Cell{Data, Dim, T, L}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.build_face","text":"f = build_face(dir, left, right)\n\nConstruct a face with normal direction index dir having adjacent cells  left and right.  With this constructor, dir is always positive, and  points from left to right.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.build_face_dissipation-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Array{Face{Dim, T, Cell}, 1}, Any, Any, Any}} where {Dim, T, Cell}","page":"Home","title":"CloudSBP.build_face_dissipation","text":"face_diss = build_face_dissipation(ifaces, xc, degree, levset,\n                                   [, fit_degree=degree])\n\nReturns a Dissipation type that can be used for artificial dissipation over a  point cloud.  iface is a list of interfaces, and xc[:,i] are the  coordinates of the ith point in the cloud.  degree is the polynomial degree  for which the interpolations to the faces is exact.  levset defines a  level-set geometry, and the optional kwarg fit_degree indicates the degree of  the Bernstein polynomials used to approximate the level-set within the Algoim  library.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.build_first_derivative-NTuple{6, Any}","page":"Home","title":"CloudSBP.build_first_derivative","text":"sbp = build_first_derivative(mesh, bc_map, xc, levset, levset_grad!, degree\n                             [, fit_degree=degree])\n\nConstructs first-derivative SBP operators of degree degree based on the  background mesh, nodes xc, level-set levset (and its gradient,  levset_grad!).  fit_degree sets the polynomial degree used by Algoim to  approximate the level set.  bc_map determines the type of each boundary.\n\nPRE: The cell norms must be stored in the cell data.wts[:] attribute.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.build_interfaces-Union{Tuple{RegionTrees.Cell{Data, Dim, T, L}}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.build_interfaces","text":"faces = build_interfaces(root)\n\nCreates an array of faces between adjacent leaves (i.e. cells) of the tree  root.  This array does not include boundary faces that have only one adjacent  cell; see build_boundary_faces for such a list.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.build_interpolation!-NTuple{6, Any}","page":"Home","title":"CloudSBP.build_interpolation!","text":"build_interpolation!(interp, degree, x, x_interp, xref, dx)\n\nCreates the matrix interp that performs interpolation from nodes x to points x_interp, which is degree total polynomial degree exact.  The  arrays xref and dx are used to shift and scale the coordinates to  improve the conditioning of the Vandermonde matrix.\n\nNote: This routine assumes that x is unisolvent.  Also, the matrix  interp is the minmum-norm solution when there are more nodes in x than  total degree basis functions.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.build_mesh-Union{Tuple{T}, Tuple{Dim}, Tuple{Any, StaticArraysCore.SVector{Dim, T}, Any, Any}} where {Dim, T}","page":"Home","title":"CloudSBP.build_mesh","text":"mesh = build_mesh(points, widths, levset, min_width \n                  [, origin=SVector(ntuple(i -> 0.0, Dim))])\n\nBuilds the background Cartesian mesh.  The root cell has its origin at origin  and has widths lengths.  The level-set levset defines any immersed boundary  based on where levset(x) = 0; the domain is the intersection of the root  cell's domain and where levset(x) >= 0.  The mesh is refined based on the  given points points and it is refined at the zero level-set until the cut  cell have dimensions of min_width or smaller.\n\nNOTE: If you want a degree p SBP operator, set degree=2*p-1 so that the  stencil is sufficiently large for the diagonal mass matrix.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.build_nn_stencils!-Tuple{Any, Any, Any}","page":"Home","title":"CloudSBP.build_nn_stencils!","text":"build_nn_stencils!(root, points, degree [, tol=5*10^degree, \n                   max_iter=2*degree+1])\n\nThe stencil for each leaf in the tree root is determined and the indices of  the stencil are stored in the leaves.  The stencil is determined using k  neareast neighbors, where k is the number of points needed for a  well-conditioned Vandermonde matrix of total degree degree.  The tolerance  tol is used to determine what is considered well-conditioned.  A maximum of  max_iter iterations are used to find a suitable stencil; after the maximum  iterations are exceeded, the method accepts the stencil as is.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.calc_error-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Function, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 4}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.calc_error","text":"L2_error, max_error = calc_error(exact, root, xc, degree, u, levset [, \n                                 quad_degree=2*degree, fit_degree=degree])\n\nReturns the L2 and max error of a given solution u.  The exact solution is  provided by the function exact.  The background mesh is root and the nodes  are xc.  degree is the degree of the solution, while quad_degree and  fit_degree are the quadrature and level-set levset fitting degrees,  respectively.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.calc_moments!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.calc_moments!","text":"m = calc_moments!(root, levset, degree, fit_degree)\n\nReturns the first total degree integral moments for all cells in the tree defined by root.  The tree must have been preprocessed to identify poentially cut and immersed cells using the levset level-set function.  In addition, the  cell.data.xref and cell.data.dx fields must contain the reference origin for each cell.\n\nWARNING: The signature of the function levset must of the form levset(Vector{Float64})::Float64, because this assumption is used when it is wrapped using csafe_function.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.calc_moments!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.calc_moments!","text":"m = calc_moments!(root, degree)\n\nThis variant is useful when you want moments for all cells in the tree root,  i.e. no level-set function.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_null_and_part-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Val{Dim}}} where Dim","page":"Home","title":"CloudSBP.cell_null_and_part","text":"w = cell_null_and_part(degree, xc, moments, xref, dx, Val(Dim))\n\nGiven a set of total degree polynomial moments, computes a quadrature that is exact for those moments based on the nodes xc as well as the null space of the quadrature conditions  The arrays xref and dx are used to shift and scale, respectively, the nodes in xc to improve conditioning of the Vandermonde matrix.  The same scaling and shifts must have been applied when computing the integral moments.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, AbstractMatrix{ComplexF64}, Any, Any, Any, Val{Dim}}} where Dim","page":"Home","title":"CloudSBP.cell_quadrature","text":"w = cell_quadrature(degree, xc, moments, xref, dx, Val(Dim))\n\nPartially complexified version of cell_quadrature; partially, because  solve_min_norm! does not work with complex variables, so that function is  differentiated explicitly here.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, AbstractMatrix{ComplexF64}, Any, Any, Val{Dim}}} where Dim","page":"Home","title":"CloudSBP.cell_quadrature","text":"w = cell_quadrature(degree, xc, xq, wq, Val(Dim))\n\nComplexified version of cell_quadrature for testing derivatives.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Val{Dim}}} where Dim","page":"Home","title":"CloudSBP.cell_quadrature","text":"w = cell_quadrature(degree, xc, moments, xref, dx, Val(Dim))\n\nGiven a set of total degree polynomial moments, computes a quadrature that is exact for those moments based on the nodes xc.  The arrays xref and dx are used to shift and scale, respectively, the nodes in xc to improve  conditioning of the Vandermonde matrix.  The same scaling and shifts must have been applied when computing the integral moments.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_quadrature-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Val{Dim}}} where Dim","page":"Home","title":"CloudSBP.cell_quadrature","text":"w = cell_quadrature(degree, xc, xq, wq, Val(Dim))\n\nGiven a quadrature rule (xq,wq) that is exact for polynomials of degree  degree, computes a new quadrature for the same domain based on the nodes xc.  This version computes the moments from scratch.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_quadrature_rev!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim","page":"Home","title":"CloudSBP.cell_quadrature_rev!","text":"cell_quadrature_rev!(xc_bar, degree, xc, moments, xref, dx, w_bar, Val(Dim))\n\nReverse mode differentiated of the moment-based variant of cell_quadrature. Returns the derivatives of dot(w, w_bar) with respect to xc in the array xc_bar.  All other inputs are the same as the moment-based variant of cell_quadrature.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_quadrature_rev!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim","page":"Home","title":"CloudSBP.cell_quadrature_rev!","text":"cell_quadrature_rev!(xc_bar, degree, xc, xq, wq, w_bar, Val(Dim))\n\nReverse mode differentiated cell_quadrature.  Returns the derivatives of  dot(w, w_bar) with respect to xc in the array xc_bar.  All other inputs are the same as cell_quadrature.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_side_rect-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, RegionTrees.Cell{Data, Dim, T, L}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.cell_side_rect","text":"rect = build_cell_face(dir, cell)\n\nConstruct a HyperRectangle for given cell on side dir.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_skew_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.cell_skew_part","text":"S = cell_skew_part(E, H, cell, xc, degree)\n\nReturns the skew-symmetric parts of SBP diagonal-norm operators for the element cell based on the nodes xc.  The operator is exact for polynomials of total  degree degree.  The diagonal norm for the cell is provided in the array H,  which must be exact for degree 2*degree - 1 polynomials over xc.  Finally, the symmetric part of the SBP operators must be provided in E.  Note that E and the returned S are three dimensional arrays, with E[:,:,d] and S[:,:,d] holding the operators for the direction d.\n\nNOTE: E and H must be compatible, in the sense of SBP operators.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.cell_symmetric_part","text":"E = cell_symmetric_part(cell, xc, degree, levset [,fit_degree=degree])\n\nReturns the symmetric part of the first-derivative SBP operator for the  possibly cut cell cell.  The point cloud associated with cell is xc,  and the boundary operator uses 2*degree exact quadrature.  The fit_degree input indicates the degree of the Bernstein polynomial used by Algoim to approximate the level set.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.cell_symmetric_part","text":"E = cell_symmetric_part(cell, xc, degree)\n\nReturns the symmetric part of the first-derivative SBP operator for the uncut  cell cell.  The point cloud associated with cell is xc, and the boundary  operator is 2*degree exact for boundary integrals.\n\nNote: This version recomputes the 1D quadrature rule each time, and involves several allocations.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Array{Face{Dim, T, RegionTrees.Cell{Data, Dim, T, L}}, 1}, Any, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.cell_symmetric_part","text":"E = cell_symmetric_part(cell, faces, xc, degree, levset [,fit_degree=degree])\n\nReturns the symmetric part of the first-derivative SBP operator for the  possibly cut cell cell.  The point cloud associated with cell is xc,  and the boundary operator uses 2*degree exact quadrature.  The fit_degree input indicates the degree of the Bernstein polynomial used by Algoim to approximate the level set.  This variant loops over the faces of the cell, which is not necessary for uncut cells but it is necessary for cut cells.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.cell_symmetric_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Array{Face{Dim, T, RegionTrees.Cell{Data, Dim, T, L}}, 1}, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.cell_symmetric_part","text":"E = cell_symmetric_part(cell, faces, xc, degree)\n\nReturns the symmetric part of the first-derivative SBP operator for the uncut  cell cell.  The point cloud associated with cell is xc, and the boundary  operator is 2*degree exact for boundary integrals.  This variant loops over the faces of the cell, which is not necessary for uncut cells but it is necessary for cut cells.\n\nNote: This version recomputes the 1D quadrature rule each time, and involves several allocations.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.compute_sparse_constraint-NTuple{4, Any}","page":"Home","title":"CloudSBP.compute_sparse_constraint","text":"A, b = compute_sparse_constraint(root, wp, Z, H_tol)\n\nReturns the sparse matrix A and vector b that make up the linear inequality  for the diagonal mass matrix.  root is used to loop over the cells and  assemble the null-space matrices stored in Z and the minimum-norm quadrature  stored in wp.  H_tol is an array of tolerances for the diagonal entries.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.dgd_basis!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim","page":"Home","title":"CloudSBP.dgd_basis!","text":"dgd_basis!(phi, degree, xc, xq, work, Val(Dim))\n\nEvaluates the DGD basis functions phi at the points xq.  The basis functions are of total degree degree, and they are defined by the centers  xc.  The array work is used for temporary storage, and the value type Dim  is used to dispatch on the relevant dimension.\n\nIf ndims(phi) > 2, it is assumed that both the basis functions (stored in phi [:,:,q]) and their derivatives (stored in phi[:,:,2:Dim+1]) are to be  computed.  Otherwise, the basis functions are computed and returned in the 2d  array phi[:,:].\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.dgd_basis_rev!-Union{Tuple{Dim}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{Dim}}} where Dim","page":"Home","title":"CloudSBP.dgd_basis_rev!","text":"dgd_basis_rev!(xc_bar, phi_bar, degree, xc, xq, xref, dx, Val(Dim))\n\nReverse mode algorithmic differentiation of dgd_basis!.  The output xc_bar  is the derivative of the output (defined implicitly by the input phi_bar) as  a function of the coordinates in xc.  As in dgd_basis!, the basis functions  are of total degree degree, evaluated at points xq, and they are defined by  the centers xc.  The value type Dim is used to dispatch on the relevant  dimension.\n\nNote: Only differentiates the version of dgd_basis! that returns the basis functions, not their derivatives.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.diagonal_norm!-Tuple{Any, Any}","page":"Home","title":"CloudSBP.diagonal_norm!","text":"diagonal_norm!(H, root)\n\nAssembles the diagonal norm H using the particular cell-based norm stored in  the cells' data.wts field.  root stores the mesh.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.diagonal_norm!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.diagonal_norm!","text":"diagonal_norm!(H, root, points, degree)\n\nConstructs a diagonal norm (i.e. quadrature) for the nodes points and using the background mesh defined by root.\n\nPRE: The cells in root must have their data.moments, data.xref, and data.dx fields set.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.diagonal_norm_rev!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.diagonal_norm_rev!","text":"diagonal_norm_rev!(points_bar, H_bar, root, points, degree)\n\nReverse-mode differentiation of the weighted norm, dot(H, H_bar) with respect to the node coordinates in points.\n\nPRE: The cells in root must have their data.moments, data.xref, and data.dx fields set.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.diff_jacobi_poly-Union{Tuple{T}, Tuple{AbstractVector{T}, Any, Any, Int64}} where T","page":"Home","title":"CloudSBP.diff_jacobi_poly","text":"dp = diff_jacobi_poly(x, alpha, beta, N)\n\nEvaluate the first derivative of a Jacobi Polynomial at the points x.  See  the companion code for jacobipoly for an explanation of the other parameters.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.diff_proriol_poly!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64, Int64}} where T","page":"Home","title":"CloudSBP.diff_proriol_poly!","text":"diff_proriol_poly!(dP, x, y, z, i, j, k)\n\nEvaluate the derivatives of a Proriol orthogonal polynomial basis function on the right tetrahedron.  The arrays x,y, and z are the locations at which  to evaluate the polynomial, and the integers i,j, and k define the basis  function to evaluate.  The result is stored in dP.\n\nNotes: the derivatives are computed using the complex-step method (since there  are many outputs and only 3 inputs); therefore, a different method should be  used for verification of this method.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.diff_proriol_poly!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64}} where T","page":"Home","title":"CloudSBP.diff_proriol_poly!","text":"diff_proriol_poly!(dP, x, y, i, j)\n\nEvaluate the derivatives of a Proriol orthogonal polynomial basis function on the right triangle.  The arrays x and y give the locations at which to evaluate the polynomial, and the integers i and j define the basis function  to evaluate.  The result is stored in dP.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.face_quadrature!-Union{Tuple{T}, Tuple{Dim}, Tuple{Any, Any, RegionTrees.HyperRectangle{Dim, T}, Any, Any, Int64}} where {Dim, T}","page":"Home","title":"CloudSBP.face_quadrature!","text":"face_quadrature!(xq, wq, rect, x1d, w1d, dir)\n\nBuilds a tensor-product quadrature rule on a Dim-1 hyperrectangle.  The  quadrature is returned in the updated arrays xq and wq, which hold the  locations and weights, respectively.  The rule is based on the one-dimensional  quadrature defined by x1d and w1d.  The Dim-1 hyperrectuangle has a  boundary defined by rect, which has a unit normal in the Cartesian index  dir.  Note that rect is defined in Dim dimensions, and has rect.widths [dir] = 0, i.e. it has zero width in the dir direction.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.get_bounding_box-Tuple{Any, Any}","page":"Home","title":"CloudSBP.get_bounding_box","text":"box_center, box_dx = get_bounding_box(rect, x)\n\nFor a given HyperRectangle rect and point cloud x, returns the bounding box center and lengths that enclose both rect and x.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.get_complex_step-Union{Tuple{Type{T}}, Tuple{T}} where T<:Float32","page":"Home","title":"CloudSBP.get_complex_step","text":"get_complex_step(T)\n\nreturns an appropriate complex-step size for the given type\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.get_data-Tuple{Any, Any}","page":"Home","title":"CloudSBP.get_data","text":"data = get_data(cell, child_indices)\n\nReturns a CellData struct based on the given cell.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.get_neighbors-Tuple{RegionTrees.Cell, Any}","page":"Home","title":"CloudSBP.get_neighbors","text":"neighbors = get_neighbors(cell, side)\n\nConstructs a vector of all neighbors on the side boundary of leaf cell.\n\nBased on the paper here: http://www.cs.umd.edu/~hjs/pubs/SameCVGIP89.pdf See also https://geidav.wordpress.com/2017/12/02/advanced-octrees-4-finding-neighbor-nodes/\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.get_null_and_part-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.get_null_and_part","text":"wp, Z, num_vars = get_null_and_part(root, xc, degree)\n\nReturns a vector of nullspaces, Z, and particular solutions, wp, for each  cell's quadrature problem.  Also returns the total number of degrees of  freedom.  Note that wp and Z are Vectors of Vector and Matrix,  respectively.\n\nPRE: The cells in root must have their data.moments, data.xref, and data.dx fields set.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.get_points_inside","page":"Home","title":"CloudSBP.get_points_inside","text":"inside = get_points_inside(rect, points [, indices=[1:size(points,2)]])\n\nReturns the subset of integers from indices corresponding to points from  points that are inside the hyperrectangle rect.\n\n\n\n\n\n","category":"function"},{"location":"#CloudSBP.indices_within_parent-Tuple{Any}","page":"Home","title":"CloudSBP.indices_within_parent","text":"I = indices_within_parent(cell)\n\nReturns the Cartesian indices of cell with respect to its parent.  This  function assumes cell has a parent and will fail if it does not.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.interface_interp-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Any, Any, Any}} where {Dim, T, Cell}","page":"Home","title":"CloudSBP.interface_interp","text":"Rl, Rr, x, w  = interface_interp(face, xc_left, xc_right, degree)\n\nReturns interpolation operators Rl and Rr from xc_left and xc_right to x, respectively, where x is the returned averaged center of the face face.  w is the weight associate with face (its area).\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.interface_interp-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Vararg{Any, 4}}} where {Dim, T, Cell}","page":"Home","title":"CloudSBP.interface_interp","text":"Rl, Rr, x, w  = interface_interp(face, xc_left, xc_right, degree, levset\n                                 [, fit_degree=degree])\n\nThis version of the method is for planar interfaces that are cut by a level-set geometry defined by the function levset.  The optional kwarg fit_degree indicates the degree of the Bernstein polynomials used to approximate the level-set within the Algoim library.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.interface_skew_part-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Any, Any, Any}} where {Dim, T, Cell}","page":"Home","title":"CloudSBP.interface_skew_part","text":"Sface = interface_skew_part(face, xc_left, xc_right, degree)\n\nConstructs the form\n\nint_textface V_i V_j dGamma\n\nwhere the integral is over the face face with unit normal in the coordinate direction face.dir.  The functions V_i and V_j can be regarded as degree degree basis functions at the nodes i and j within the stencil of the left and right cells, respectively.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.interface_skew_part-Union{Tuple{Cell}, Tuple{T}, Tuple{Dim}, Tuple{Face{Dim, T, Cell}, Vararg{Any, 4}}} where {Dim, T, Cell}","page":"Home","title":"CloudSBP.interface_skew_part","text":"Sface = interface_skew_part(face, xc_left, xc_right, degree, levset\n                            [, fit_degree=degree])\n\nThis version of the method is for planar interfaces that are cut by a level-set geometry defined by the function levset.  The optional kwarg fit_degree indicates the degree of the Bernstein polynomials used to approximate the level-set within the Algoim library.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.is_center_immersed-Union{Tuple{T}, Tuple{Dim}, Tuple{RegionTrees.HyperRectangle{Dim, T}, Function}} where {Dim, T}","page":"Home","title":"CloudSBP.is_center_immersed","text":"inside = is_center_immersed(rect, levset)\n\nReturns true if the center of rect is inside the level-set levset, that  is, phi(xc) < 0.0.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.is_cut-Tuple{Any}","page":"Home","title":"CloudSBP.is_cut","text":"cut = is_cut(cell)\n\nReturns false if cell is not cut; note that a return of true, however,  only indicates that the cell may be cut.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.is_cut-Union{Tuple{Face{Dim, T, Cell}}, Tuple{Cell}, Tuple{T}, Tuple{Dim}} where {Dim, T, Cell}","page":"Home","title":"CloudSBP.is_cut","text":"cut = is_cut(face)\n\nReturns false if face is not cut; note that a return of true, however,  only indicates that the face may be cut.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.is_cut-Union{Tuple{T}, Tuple{Dim}, Tuple{RegionTrees.HyperRectangle{Dim, T}, Function}} where {Dim, T}","page":"Home","title":"CloudSBP.is_cut","text":"cut = is_cut(rect, levset [, fit_degree=2])\n\nReturns true if the HyperRectangle rect is intersected by the level-set  levset, and returns false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.is_immersed-Tuple{Any}","page":"Home","title":"CloudSBP.is_immersed","text":"im = is_immersed(cell)\n\nReturns true if cell is not cut and its center is immersed.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.is_immersed-Union{Tuple{Face{Dim, T, Cell}}, Tuple{Cell}, Tuple{T}, Tuple{Dim}} where {Dim, T, Cell}","page":"Home","title":"CloudSBP.is_immersed","text":"im = is_immersed(face)\n\nReturns true if face is not cut and its center is immersed.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.jacobi_poly!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Any, Any, Int64, AbstractVector{T}}} where T","page":"Home","title":"CloudSBP.jacobi_poly!","text":"jacobi_poly!(p, x, alpha, beta, N, work)\n\nEvaluate Jacobi polynomial at the points x and return in p.  Based on  JacobiP in Hesthaven and Warburton's nodal DG book.  alpha and beta are  parameters that define the type of Jacobi Polynomial (alpha + beta != 1).  N  is the polynomial degree, not the number of nodes.  The array work should be  twice the length of x.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.leaves_on_side-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Int64}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.leaves_on_side","text":"leaves = leaves_on_side(cell, side)\n\nReturns a Vector of leaves on boundary index side of given root cell.  If  cell is nothing, the Vector is returned empty.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.lg_nodes","page":"Home","title":"CloudSBP.lg_nodes","text":"x, w = lg_nodes(N [, T=Float64])\n\nComputes the Legendre-Gauss (LG) quadrature nodes x and weights w on the  interval [-1,1].  The LG nodes are the zeros of PN(x), where PN(x) denotes  the Nth Legendre polynomial.\n\nJulia version adapted from Matlab code written by Greg von Winckel - 02/25/2004 Contact: gregvw@chtm.unm.edu \n\n\n\n\n\n","category":"function"},{"location":"#CloudSBP.lgl_nodes","page":"Home","title":"CloudSBP.lgl_nodes","text":"x, w = lgl_nodes(N [, T=Float64])\n\nComputes the Legendre-Gauss-Lobatto (LGL) quadrature nodes x and weights w  on the interval [-1,1].  The LGL nodes are the zeros of (1-x^2)*P'N(x), where  PN(x) denotes the Nth Legendre polynomial.\n\nJulia version adapted from Matlab code written by Greg von Winckel - 04/17/2004 Contact: gregvw@chtm.unm.edu\n\n\n\n\n\n","category":"function"},{"location":"#CloudSBP.make_compatible!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.make_compatible!","text":"make_compatible!(E, H, cell, xc, degree)\n\nModifies the SBP symmetric operator E for cell cell such that it is compatible with the diagonal norm H.  The operators are defined over the nodes xc and are for a degree degree exact SBP first-derivative operator.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.mark_cut_cells!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Function}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.mark_cut_cells!","text":"mark_cut_cells!(root, levset)\n\nIdentifies cells in the tree root that may be cut be the level-set levset.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.mark_cut_faces!-Tuple{Any, Any}","page":"Home","title":"CloudSBP.mark_cut_faces!","text":"mark_cut_faces!(faces, levset)\n\nIdentifies faces in the list faces that may be cut be the level-set levset.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.mass_matrix-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.mass_matrix","text":"M = mass_matrix(root, xc, degree)\n\nReturns the DGD mass matrix for degree degree based on the mesh in the tree  root and the centers in xc.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.mass_obj-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.mass_obj","text":"obj = mass_obj(root, xc, xc_init, dist_ref, H_tol, mu, degree)\n\nCompute the objective that seeks to minimize the change in the node locations while ensuring a positive lumped mass matrix.  root is the mesh, xc are the  nodes being varied, and xc_init are the initial node locations. dist_ref are reference lengths, and H_tol is an array of tolerances for the lumped mass  value at each node; that is, sum_{j} M[i,j] >= H_tol[i] for the constraint to  be satisfied.  Finally, mu scales the regularization term, and degree is  the target exactness of the rule.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.mass_obj_grad!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.mass_obj_grad!","text":"mass_obj_grad!(g, root, xc, xc_init, dist_ref, H_tol, mu, degree)\n\nComputes the derivative of mass_obj with respect to xc.  See mass_obj for and explanation of the remaining parameters.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.mass_row_sums!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.mass_row_sums!","text":"mass_row_sums!(lumped_mass, root, xc, degree)\n\nFills the array lumped_mass with the sum of the rows (or columns) of the  symmetric DGD mass matrix of degree degree based on the cloud xc.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.mass_row_sums_rev!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{Any, Any, RegionTrees.Cell{Data, Dim, T, L}, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.mass_row_sums_rev!","text":"mass_row_sums_rev!(xc_bar, lumped_mass_bar, root, xc, degree)\n\nReverse-mode differentiation of the weighted norm, dot(lumped_mass, lumped_mass_bar) with respect to the node coordinates in points.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.max_leaf_stencil-Tuple{Any}","page":"Home","title":"CloudSBP.max_leaf_stencil","text":"max_stencil = max_leaf_stencil(root)\n\nReturns the largest stencil (i.e. number of points used for DGD basis) over all  leaves in the mesh defined by root.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.monomial_basis!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, Val{1}}} where T","page":"Home","title":"CloudSBP.monomial_basis!","text":"monomial_basis!(V, degree, x, Val(N))\n\nThis method computes the monomial basis of total degree degree at the points  x.  The type parameter N is used to select the appropriate spatial  dimension.  These methods are useful for testing, but given the  ill-conditioning of the corresponding Vandermonde matrix, they should not be  used to construct the DGD basis functions.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.monomial_basis_derivatives!-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, AbstractMatrix{T}, Val{1}}} where T","page":"Home","title":"CloudSBP.monomial_basis_derivatives!","text":"monomial_basis_derivatives!(dV, degree, x, Val(N))\n\nThis method and its variants compute the first derivatives of monomial basis  of total degree degree at the points x.  The type parameter N is used to  select the appropriate spatial dimension.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.neighbor_of_greater_or_equal_size-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Int64}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.neighbor_of_greater_or_equal_size","text":"nbr = neighbor_of_greater_or_equal_size(cell, side)\n\nReturns the cell on boundary index side of cell that is of the same size or  larger than cell.  Returns nothing` if no such neighbor exists.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.num_leaves-Tuple{Any}","page":"Home","title":"CloudSBP.num_leaves","text":"n = num_leaves(root)\n\nReturns the total number of leaves in the given root.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.number_immersed-Tuple{Any}","page":"Home","title":"CloudSBP.number_immersed","text":"count = number_immersed(faces)\n\nReturns the number of faces that are definitely immersed.  Note that this is  a lower bound, since the immeresed check is conservative.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.obj_norm-Union{Tuple{T2}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, AbstractArray{Vector{T2}, 1}, AbstractArray{Matrix{T2}, 1}, AbstractVector{T2}, T2, Int64}} where {Data, Dim, T, L, T2}","page":"Home","title":"CloudSBP.obj_norm","text":"obj = obj_norm(root, wp, Z, y, rho, num_nodes)\n\nCompute the objective to maximize the minimum norm.  root is the mesh, which  is mostly needed to known the stencil for each cell.  wp is a vector of  vectors holding the particular solution for each cell, and Z is the nullspace  for each cell's problem.\n\nNOTE: this objective is deprecated.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.obj_norm_grad!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, AbstractArray{Vector{T}, 1}, AbstractArray{Matrix{T}, 1}, AbstractVector{T}, T, Int64}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.obj_norm_grad!","text":"obj_norm_grad!(g, root, wp, Z, y, num_nodes)\n\nCompute the gradient of the objective to maximize the minimum norm.  root is  the mesh, which is mostly needed to known the stencil for each cell.  wp is a  vector of vectors holding the particular solution for each cell, and Z is the  nullspace for each cell's problem.  \n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.obj_slice-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 7}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.obj_slice","text":"obj_slice(root, xc, degree, H_tol, mu, dist_ref, node, pert)\n\nReturns an array of objective function values along a slice based on perturbing  node node in the direction pert.  Used for visualizing.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.opt_norm!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.opt_norm!","text":"H = opt_norm!(root, xc, degree, H_tol, mu, dist_ref, max_rank)\n\nFinds an approximate minimizer for the objective penalty with respect to the node coordinates xc and based on the background mesh root.  Once an approximate solution is found, the corresponding H norm is returned; note  that the xc coordinates are altered in the process.  The parameter max_rank determines the rank of the approximate Jacobian of the norm with respective to  the nodes, and this approximate Jacobian is used to form an approximate inverse Hessian.  See penalty for explanations of the other parameters.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.output_pyplot-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Any, Any, Any}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.output_pyplot","text":"xplot, uplot = output_pyplot(root, xc, degree, u [, num_pts=degree+1])\n\nOutputs \"meshgrid\" type data for each cell in root for plotting the contours  of the state u using Matplotlib.  The solution is of degree degree and  num_pts samples are used in each direction on each cell.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.output_vtk-Union{Tuple{L}, Tuple{T}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, 2, T, L}, Any, Any, Any}} where {Data, T, L}","page":"Home","title":"CloudSBP.output_vtk","text":"vtk = output_vtk(root, xc, degree, u [, num_pts=degree+1,\n                 filename=\"solution\", save=true])\n\nCreates a VTK file for a scalar solution based on the mesh in root, the points xc, and the solution coefficients in u.  The reconstruction used is of degree degree, although only the solution is only interpolated to the  cell vertices at this time (i.e. the cell's themselves are not high-order in  Paraview).\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.penalty-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.penalty","text":"obj = penalty(root, xc, xc_init, dist_ref, H_tol, mu, degree)\n\nCompute the objective that seeks to minimize the change in the node locations while ensuring positive quadrature weights.  root is the mesh, xc are the  nodes being varied, and xc_init are the initial node locations. dist_ref are reference lengths, and H_tol is an array of tolerances for the quadrature  weight at each node; that is, H[i] >= H_tol[i] for the constraint to be  satisfied.  Finally, mu scales the regularization term, and degree is the  target exactness of the rule.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.penalty_grad!-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{AbstractVector{T}, RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 6}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.penalty_grad!","text":"penalty_grad!(g, root, xc, xc_init, dist_ref, H_tol, mu, degree)\n\nComputes the derivative of penalty with respect to xc.  See penalty for an explanation of the remaining parameters.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.point_data_vtk-Tuple{Any, Any, Any}","page":"Home","title":"CloudSBP.point_data_vtk","text":"point_data_vtk(xc, data, label [, filename=\"point_data\"])\n\nWrites the points xc to the file \"point_data\".  data is a (possibly  empty) Vector of arrays that holds data to be associated with each node, and  label is a label associated with it.\n\nExample\n\n# write data to plot the norm and its sign at each node\npoint_data_vtk(xc, [abs.(H), sign.(H)], [\"norm-mag\", \"norm-sign\"])\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.points_vtk-Tuple{Any}","page":"Home","title":"CloudSBP.points_vtk","text":"points_vtk(xc [, filename=\"points\"])\n\nWrites the cloud points xc to the file \"points.vtu\".\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.poly_basis!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, AbstractVector{T}, Val{1}}} where T","page":"Home","title":"CloudSBP.poly_basis!","text":"poly_basis!(V, degree, x, work, Val(N))\n\nThis method and its variants compute the approporiate polynomial basis of total  degree degree at the points x.  The type parameter N is used to select  the appropriate spatial dimension.  The size of work should be N+1 times  the number of rows in V.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.poly_basis_derivatives!-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, AbstractMatrix{T}, Val{1}}} where T","page":"Home","title":"CloudSBP.poly_basis_derivatives!","text":"poly_basis_derivatives!(dV, degree, x, Val(N))\n\nThis method and its variants compute the first derivatives of polynomial basis  of total degree degree at the points x.  The type parameter N is used to  select the appropriate spatial dimension.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.proriol_poly!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64, Int64, AbstractVector{T}}} where T","page":"Home","title":"CloudSBP.proriol_poly!","text":"proriol_poly!(p, x, y, z, i, j, k, work)\n\nEvaluate a Proriol orthogonal polynomial basis function on the right  tetrahedron and return in array p.  The arrays x,y, and z are the  locations at which to evaluate the polynomial, and the integers i,j, and  k define the basis function to evaluate; see Hesthaven and Warburton's Nodal  DG book, for example, for a reference.  The work array should be at least 4  times the length of p.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.proriol_poly!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Int64, Int64, AbstractVector{T}}} where T","page":"Home","title":"CloudSBP.proriol_poly!","text":"proriol_poly!(p, x, y, i, j, work)\n\nEvaluate a Proriol orthogonal polynomial basis function on the right triangle  and return in array p.  The arrays x and y give the locations at which to  evaluate the polynomial, and the integers i and j define the basis function  to evaluate; see Hesthaven and Warburton's Nodal DG book, for example, for a  reference.  work is a vector that should be 3 times the length of p.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.push_new_face!-Union{Tuple{T}, Tuple{CloudSBP.BoundaryOperator{T}, Any, Any, Any}} where T","page":"Home","title":"CloudSBP.push_new_face!","text":"xq, nrm, dof, prj = push_new_face!(bndry, Dim, num_nodes, num_quad)\n\nCreates new memory at the end of the fields in the given BoundaryOperator and  returns references to the newly created arrays.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.quadrature!-Union{Tuple{T}, Tuple{Dim}, Tuple{Any, Any, RegionTrees.HyperRectangle{Dim, T}, Any, Any}} where {Dim, T}","page":"Home","title":"CloudSBP.quadrature!","text":"quadrature!(xq, wq, rect, x1d, w1d)\n\nBuilds a tensor-product quadrature for the domain defined by rect using the  one-dimensional quadratrure defined by the nodes x1d and the weights w1d.   The tensor-product quadrature nodes and weights are given by xq and wq,  respectively.  These are stored in 2-d and 1-d array formats.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.refine_on_levelset!-NTuple{4, Any}","page":"Home","title":"CloudSBP.refine_on_levelset!","text":"refine_on_levelset!(root, points, levset, min_widths)\n\nRefines the leaves in root until each cut leaf is less than min_widths dimensions.  The array of points are needed so that refined leaves have the  necessary data.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.refine_on_points!-Tuple{Any, Any}","page":"Home","title":"CloudSBP.refine_on_points!","text":"refine_on_points!(root, points)\n\nRefines the tree root until each cell has at most one of the points in  points. \n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.set_xref_and_dx!-Tuple{Any, Any}","page":"Home","title":"CloudSBP.set_xref_and_dx!","text":"set_xref_and_dx!(root, points)\n\nFor each leaf in root, finds a reference position and reference scale for leaf.data.xref and leaf.data.dx, respectively.  The reference position is, roughly, the average of the coordinates points[:,leaf.data.points] and the  leaf's boundary.  The reference scale is the extent of the coordinates and  boundary.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.skew_operator-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 5}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.skew_operator","text":"S = skew_operator(root, ifaces, bfaces, xc, levset, degree\n                  [, fit_degree=degree, use_cell_wts=true])\n\nConstructs the skew-symmetric part of a (global), first-derivative SBP  operator.  The integration mesh is given by root and xc defines the cloud  of distributed nodes where the degrees of freedom are stored.  ifaces is an  array of interfaces and bfaces is an array of boundary faces corresponding to root.  levset is a function that defines the immersed geomtry, if any.  The skew-symmetric matrix is degree degree exact.  Finally, fit_degree gives  the polynomial degree of the Bernstein polynomials used to approximate levset  by the Algoim library.  If use_cell_wts is true, the cell-based norm is formed using the data in cell.data.wts.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.solve_min_norm!-Tuple{Any, Any, Any}","page":"Home","title":"CloudSBP.solve_min_norm!","text":"solve_min_norm!(w, V, b)\n\nFinds the minimum norm solution to transpose(V) w = b.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.solve_min_norm_diff!-NTuple{5, Any}","page":"Home","title":"CloudSBP.solve_min_norm_diff!","text":"solve_min_norm_diff!(w, dw, V, dV, b)\n\nForward mode of solve_min_norm! treating b as constant.  This is useful for verifying the reverse mode implementation.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.solve_min_norm_rev!-NTuple{4, Any}","page":"Home","title":"CloudSBP.solve_min_norm_rev!","text":"solve_min_norm_rev!(V_bar, w_bar, V, b)\n\nReverse mode of solve_min_norm!.  On entry, w_bar holds the derivatives of the objective w.r.t. the weights.  On exit, V_bar holds the derivatives of the objective w.r.t. the matrix V.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.solve_norm!-NTuple{4, Any}","page":"Home","title":"CloudSBP.solve_norm!","text":"H, success = solve_norm!(root, xc, degree, H_tol [, verbose=false])\n\nAttempts to solve the norm-inequality problem using the interior-point method  implemented in the Tulip.jl package.  root defines the background mesh, xc  are the nodes, degree is the target degree of the norm, and H_tol holds the  lower bound on the norm entries.  If verbose is true, the \"OutputLevel\"  attribute of Tulip is set to 1 (so more output is provided).  The method  returns the diagonal norm, H, and a Bool, success, that indicates whether  Tulip was successful (success=true) or not.  If the problem was not  successfully solved, H is returned with the minimum-norm quadrature weights  (which likely have some negative weights).\n\nPRE: The cells in root must have their data.moments, data.xref, and data.dx fields set.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.stencil_stats-Tuple{CloudSBP.Mesh}","page":"Home","title":"CloudSBP.stencil_stats","text":"max_stencil, avg_stencil = stencil_stats(mesh)\n\nReturns the maximum cell stencil size and the average stencil size.  Only cells that are non immersed are included, since immersed cells should have empty  stencils.\n\nPRE: The cells in mesh must have their stencils defined; this should be  the case if a high-level mesh construction was used (e.g. build_mesh).\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.symmetric_operator-Union{Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, Dim, T, L}, Vararg{Any, 5}}} where {Data, Dim, T, L}","page":"Home","title":"CloudSBP.symmetric_operator","text":"E = symmetric_operator(root, ifaces, bfaces, xc, levset, degree\n                       [, fit_degree=degree])\n\nConstructs the symmetric part of a (global), first-derivative SBP operators as an SVector of sparse matrices; only the symmetric part is stored. The integration mesh is given by root and xc defines the cloud of distributed nodes where the degrees of freedom are stored.  ifaces is an array of intefaces and bfaces is an array of boundary faces corresponding to root. levset is a function that defines the immersed geomtry, if any.  The symmetric matrix is degree degree exact.  Finally, fit_degree gives the polynomial degree of the Bernstein polynomials used to approximate levset by the Algoim library.\n\nNote: The sparse matrices are not useful for much other than verifying the accuracy of the global skew-symmetric parts; this is because we do not distinguish different boundaries, nor do we provide the decomposition of the symmetric part into interpolation operators and face quadrature.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.tensor_basis!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, AbstractVector{T}, Val{1}}} where T","page":"Home","title":"CloudSBP.tensor_basis!","text":"tensor_basis!(V, degree, x, Val(N))\n\nThis method computes the tensor-product basis of degree degree at the points  x.  The type parameter N is used to select the appropriate spatial  dimension.\n\n\n\n\n\n","category":"method"},{"location":"#CloudSBP.unsteady_vtk-Union{Tuple{L}, Tuple{T}, Tuple{Data}, Tuple{RegionTrees.Cell{Data, 2, T, L}, Vararg{Any, 4}}} where {Data, T, L}","page":"Home","title":"CloudSBP.unsteady_vtk","text":"unsteady_vtk(root, xc, degree, t, sol [, num_pts=degree+1,\n             filename=\"unsteady\"])\n\nWrites a Paraview collection in order to visualizae an unsteady solution.  The solution at time t[k] is stored in sol[:,k].  See output_vtk for an explanation of the other inputs.\n\n\n\n\n\n","category":"method"},{"location":"#RegionTrees.needs_refinement-Tuple{CloudSBP.LevelSetRefinery, Any}","page":"Home","title":"RegionTrees.needs_refinement","text":"This method is for determining if cut cells need further refinement.\n\n\n\n\n\n","category":"method"},{"location":"#RegionTrees.needs_refinement-Tuple{CloudSBP.PointRefinery, Any}","page":"Home","title":"RegionTrees.needs_refinement","text":"refine = needs_refinement(r, cell)\n\nReturns true if cell has more than one point in it.\n\n\n\n\n\n","category":"method"},{"location":"#RegionTrees.refine_data-Tuple{CloudSBP.LevelSetRefinery, RegionTrees.Cell, Any}","page":"Home","title":"RegionTrees.refine_data","text":"This method, which is almost identical to the above method, is used when  refining cells that are cut by a given levelset.\n\n\n\n\n\n","category":"method"},{"location":"#RegionTrees.refine_data-Tuple{CloudSBP.PointRefinery, RegionTrees.Cell, Any}","page":"Home","title":"RegionTrees.refine_data","text":"child_data = refine_data(r, cell, indices)\n\nReturns data for child of cell with indices.\n\n\n\n\n\n","category":"method"}]
}
